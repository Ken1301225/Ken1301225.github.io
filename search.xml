<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MoE大模型剪枝以及量化</title>
      <link href="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/"/>
      <url>/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-混合专家模型"><a class="markdownIt-Anchor" href="#1-混合专家模型"></a> 1. 混合专家模型</h1><ul><li>与稠密模型相比，<strong>预训练速度更快</strong></li><li>与具有相同的参数数量的模型相比，<strong>有更快的推理速度</strong></li><li>需要<strong>大量显存</strong>，因为所有专家都要加载到内存中</li></ul><h2 id="11-moe的基础架构"><a class="markdownIt-Anchor" href="#11-moe的基础架构"></a> 1.1. MoE的基础架构</h2><blockquote><p>参考文献 <a href="https://arxiv.org/abs/2503.07137">A comprehensive survey of mixture-of-experts: Algorithms, theory, and applications</a></p></blockquote><h3 id="111-门控函数"><a class="markdownIt-Anchor" href="#111-门控函数"></a> 1.1.1. 门控函数</h3><p>决定输入数据是如何分配给指定的专家的</p><ul><li>门控函数的评价标准<ol><li>门控函数必须要同时兼顾输入和专家的特征. 相似的数据应该分配给相同的专家或者专家组, 使得专家专业化</li><li>输入数据应该尽可能均匀地分配给预定义的专家.</li></ol></li></ul><h4 id="1111-线性门控-softmax-门控"><a class="markdownIt-Anchor" href="#1111-线性门控-softmax-门控"></a> 1.1.1.1.  线性门控 (softmax 门控)</h4><p><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251015174648.png" alt="img" width="431px"></p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>o</mi><mi>p</mi><mi>K</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TopK(\cdot,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 函数: 获得在N个专家中前k高的专家得分, 其他置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是输入. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 是一个线性方程, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">R</mi><mrow><mi>n</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{R}_{noise}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 代表鼓励专家探索的噪声</li><li>softmax和TopK函数的先后可以灵活设置<ul><li>如果先进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>o</mi><mi>p</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TopK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><ul><li>可以先筛选出k个专家, 从而减少一些计算量</li></ul></li><li>如果后进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>o</mi><mi>p</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TopK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><ul><li>得出的结果不服从某个分布, 还需要额外归一化</li><li>后进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>o</mi><mi>p</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TopK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 可以充分利用分较低的专家</li></ul></li></ul></li></ul><h4 id="1112-非线性门控"><a class="markdownIt-Anchor" href="#1112-非线性门控"></a> 1.1.1.2. 非线性门控</h4><ul><li><strong>基于与余弦距离</strong></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">TopK</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">softmax</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><msup><mi>E</mi><mi>T</mi></msup><msub><mi>W</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><mi>x</mi></mrow><mrow><mi>τ</mi><mi mathvariant="normal">∥</mi><msub><mi>W</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∥</mi><mi>E</mi><mi mathvariant="normal">∥</mi></mrow></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(x)=\operatorname{TopK}(\operatorname{softmax}(\frac{E^TW_{linear}x}{\tau\|W_{linear}\|\|E\|}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.454331em;vertical-align:-0.936em;"></span><span class="mop"><span class="mord mathrm">T</span><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm">K</span></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">t</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mord">∥</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∥</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是MoE模块的输入. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{linear}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个可学习的线性变换, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mi>e</mi></msub><mo>×</mo><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">E\in\mathbb{R}^{d_e\times N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span> 代表N个专家网络的特征</p></li><li><p>将输入进行线性映射, 再与专家的嵌入计算余弦相似性</p><ul><li>如此, 专家嵌入可以捕捉不同专家的特征表示, 并逐渐优化适应任务需求</li><li>此外, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span> 是温度参数控制门控分布的锐度<ul><li>小的时候倾向于选择更少的专家</li><li>反之倾向于选择更加多的专家, 分布也更加平缓</li></ul></li></ul></li><li><p><strong>基于指数族分布</strong></p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>ν</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mi>β</mi><mi>j</mi></msub><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>ν</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>β</mi><mi>i</mi></msub><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>ν</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">G_j(x,\nu)=\frac{\beta_jD(x|\nu_j)}{\sum_{i}\beta_iD(x|\nu_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.06366em;">ν</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.41271em;vertical-align:-0.9857100000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.06366em;">ν</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.06366em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.06366em;">ν</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.06366em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857100000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>β</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\beta_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 这里是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个专家网路的先验概率. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>ν</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x|\nu_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.06366em;">ν</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.06366em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 属于指数族分布, 是输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 在第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个专家网络下的条件概率密度函数</p></li><li><p>克服了由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">softmax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span></span></span></span> 引入的非线性关系以及后续的额外迭代优化步骤 (如迭代加权最小二乘法)</p></li><li><p><strong>Soft MoE</strong></p></li><li><p>具体而言，Soft MoE计算每个令牌与每个专家之间的权重，然后使用这些权重进行加权平均以生成输入slots。因此，每个专家处理的slots是所有令牌的加权组合，而非单个令牌。</p></li><li><p><strong>Student-t distribution</strong></p></li><li><p><strong>deepseekMoE</strong>：<img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017152203.png" alt="419"></p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">N_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个共享专家，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">N_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个路由专家, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{i,t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 是亲和度,</li></ul></li></ul><h3 id="112-专家网络"><a class="markdownIt-Anchor" href="#112-专家网络"></a> 1.1.2. 专家网络</h3><h4 id="1121-替代ffn层"><a class="markdownIt-Anchor" href="#1121-替代ffn层"></a> 1.1.2.1. 替代FFN层</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">MoE(x)</mi><mo>⁡</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi><mi>D</mi></mrow></munder><msub><mi>w</mi><mi>i</mi></msub><msub><mi>M</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{MoE(x)} = \sum_{i\in ID}w_iM_i(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">M</span><span class="mord mathrm">o</span><span class="mord mathrm">E</span><span class="mord mathrm">(</span><span class="mord mathrm">x</span><span class="mord mathrm">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3717110000000003em;vertical-align:-1.321706em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">ID</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 表示的是门控网络中选中的专家, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_i(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 是一个两层的前馈神经网络</p><ul><li>逻辑: FFN层具有更高的稀疏性和领域专业性<ul><li>为了防止过拟合,并不是全连接层里的所有单元均会被同时激活</li><li>Emergent Modularity (涌现模块化) 现象</li></ul></li></ul><h4 id="1122-在注意力模块添加moe"><a class="markdownIt-Anchor" href="#1122-在注意力模块添加moe"></a> 1.1.2.2. 在注意力模块添加MoE</h4><p><strong>MoA</strong>: mixture of attention</p><ul><li>由一些列参数不同的注意力头组成, 这些注意力头被视作是专家<ul><li>对于给定的输入, 门控网络选择TopK个注意力头</li><li>输出: 被选择的头的输出的加权和</li></ul></li><li>关键优势: 不需要使用全部的注意力头来处理每个输入</li></ul><p><strong>SwitchHead</strong></p><ul><li>为每个头的QKV以及输出的投影矩阵都引入MoE机制</li></ul><p><strong>MoH</strong></p><ul><li>共享头和两阶段路由策略</li></ul><h3 id="113-路由策略"><a class="markdownIt-Anchor" href="#113-路由策略"></a> 1.1.3. 路由策略</h3><ul><li><p><strong>MaskMoE</strong></p><ul><li>为词汇表的每个token生成一个掩码向量, 针对不同频率的token调整可见专家的数量<ul><li>频率低的token, 通过掩码, 限制它只能路由到单一专家, 确保这些token的训练一致性</li><li>对于频率高的token, 允许路由到多个专家</li></ul></li></ul></li><li><p><strong>token循环路由策略</strong>，该策略采用循环神经网络根据输入序列上下文动态调整专家选择。</p></li><li><p><strong>节点受限路由</strong>：</p></li></ul><h3 id="114-训练策略"><a class="markdownIt-Anchor" href="#114-训练策略"></a> 1.1.4. 训练策略</h3><h4 id="1141-辅助损失函数设计"><a class="markdownIt-Anchor" href="#1141-辅助损失函数设计"></a> 1.1.4.1. 辅助损失函数设计</h4><p>训练中要防止模型坍塌, 也就是很少一部分专家获得了大部分输入, 导致负载不均衡</p><ul><li><strong>Importance and Load loss functions</strong></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>X</mi><msub><mo stretchy="false">)</mo><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></munder><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Load(X)_i=\sum_{x\in X}P(x,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3717110000000003em;vertical-align:-1.321706em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mi>X</mi><msub><mo stretchy="false">)</mo><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></munder><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><msub><mo stretchy="false">)</mo><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Importance(X)_i = \sum_{x\in X}G(x)_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3717110000000003em;vertical-align:-1.321706em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mrow><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi></mrow></msub><mtext> </mtext><mo>⋅</mo><mo stretchy="false">(</mo><mi>C</mi><mi>o</mi><mi>V</mi><mo stretchy="false">(</mo><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L_{load}(X) = w_{load}\ \cdot (CoV(Load(X)))^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.59445em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>I</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mrow><mi>I</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow></msub><mtext> </mtext><mo>⋅</mo><mo stretchy="false">(</mo><mi>C</mi><mi>o</mi><mi>V</mi><mo stretchy="false">(</mo><mi>I</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L_{Importance}(X) = w_{Importance}\ \cdot (CoV(Importance(X)))^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.730558em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mo stretchy="false">{</mo><mo>⋅</mo><mo stretchy="false">}</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{\{\cdot\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">{</span><span class="mord mtight">⋅</span><span class="mclose mtight">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 为超参数, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 为给定新的随机噪声选择的情况下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(x,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 不为0的概率, CoV是变异系数 (标准差/均值)</p></li><li><p>两者都添加进模型损失函数</p></li><li><p><strong>Switch Transformer</strong>:</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mn>1</mn><mo stretchy="false">{</mo><mi mathvariant="normal">argmax</mi><mo>⁡</mo><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f_i=\frac{1}{T}\sum_{x\in\mathcal{B}}\mathbb{1}\{\operatorname{argmax}G(x)=i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.6431459999999998em;vertical-align:-1.321706em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">1</span></span><span class="mopen">{</span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">}</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><msub><mo stretchy="false">)</mo><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Q_i=\frac{1}{T} \sum_{x\in\mathcal{B}}G(x)_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.6431459999999998em;vertical-align:-1.321706em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>α</mi><mtext> </mtext><mo>⋅</mo><mi>N</mi><mtext> </mtext><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>f</mi><mi>i</mi></msub><mtext> </mtext><mo>⋅</mo><msub><mi>Q</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">loss = \alpha\  \cdot N\ \cdot\sum_{i=1}^{N} f_i\ \cdot Q_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 是一个batch中的tokens的总数量, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span></span> 是batch中的token集合, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是赋予专家i的token的比例, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Q_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是专家i的路由概率比例</p></li><li><p>当均匀分配时取到最小损失</p></li><li><p><strong>deepseekMoE</strong>：<img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017153107.png" alt="img" width="433px"></p></li></ul><h4 id="1142-专家选择"><a class="markdownIt-Anchor" href="#1142-专家选择"></a> 1.1.4.2. 专家选择</h4><ul><li><strong>TopK</strong>策略</li><li><strong>TopP</strong>策略<ul><li>通过设置概率阈值, 决定每个时间步决定激活的专家个数</li><li>门控网络计算每个专家的分数, 对应专家被选中的概率分布, 并通过降序的方式排列.</li><li>然后，该策略逐步累积专家的分数，直到累积值超过P，激活所有累积的专家来处理该令牌。</li></ul></li><li><strong>dropout regularization for HMoE(层次混合专家)</strong><ul><li>随机丢掉不同分支的专家网络</li></ul></li></ul><h4 id="1143-流水线设计"><a class="markdownIt-Anchor" href="#1143-流水线设计"></a> 1.1.4.3. 流水线设计</h4><ul><li><strong>BPR</strong></li><li><strong>RMoE</strong></li></ul><h3 id="115-系统设计"><a class="markdownIt-Anchor" href="#115-系统设计"></a> 1.1.5. 系统设计</h3><h4 id="1151-计算"><a class="markdownIt-Anchor" href="#1151-计算"></a> 1.1.5.1. 计算</h4><p>特别是在大规模分布式系统环境中，标准的MoE架构要求专家操作之间进行同步, 所有专家全完成后才能进入下步计算</p><ul><li>文献[15]提出并讨论了几种并行策略，包括数据并行、专家并行和模型并行，但不同的并行方法对数据和模型参数的分布有不同的要求。</li><li>为了使系统能够快速适应动态负载变化，[50]设计了一种统一的分布布局来管理模型的参数和输入数据。这可以适应各种并行策略的分布需求，实现并行策略的零成本切换。</li><li><strong>Soft MoE</strong> [27]提出了一种改进的调度算法，该算法采用基于梯度的路由选择方法，使计算过程更加平稳高效。这种方法减少了不必要的同步等待时间，降低了整体同步开销，并提高了系统吞吐量和效率。</li><li><strong>DeepSeekV3</strong>：<img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017151724.png" alt="img" width="493px"></li></ul><h2 id="12-量化"><a class="markdownIt-Anchor" href="#12-量化"></a> 1.2. 量化</h2><blockquote><p>文章参考：<a href="https://blog.csdn.net/penriver/article/details/136411485">大模型（LLM）的量化技术Quantization原理学习_大模型量化-CSDN博客</a>和 <a href="https://zhuanlan.zhihu.com/p/20869179493">2w字解析量化技术，全网最全的大模型量化技术解析 - 知乎</a> 以及文献 <a href="https://dl.acm.org/doi/abs/10.1145/3728636">Efficient Compressing and Tuning Methods for Large Language Models</a></p></blockquote><h3 id="121-神经网络中的数据形式"><a class="markdownIt-Anchor" href="#121-神经网络中的数据形式"></a> 1.2.1 神经网络中的数据形式</h3><p><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251016143409.png" alt="img" width="351px"></p><ul><li><strong>FP32</strong>: 在深度学习中，单精度浮点数格式FP32是一种广泛使用的数据格式</li><li><strong>Tensor Float 32</strong>: Tensor Float 32是Tensor Core支持新的数值类型，从NVIDIA A100中开始支持。A100的普通FP32的峰值计算速度为19.5TOPs，而TF32的峰值计算速度为156TOPs，提升了非常多<ul><li>在深度学习中，其实我们对浮点数的表示范围比较看重，而有效数字不是那么重要。在这个前提下，TF直接就把FP32中23个分数值截短为10bits，而指数位仍为8bits，总长度为19 (=1+8+10) bits。至于为什么是10bits 就够了，那是因为FP16就只有10bits用来表示分数值。而在实际测试中，FP16的精度水平已经足够应对深度学习负载，只是表示的范围不够广而已</li></ul></li><li><strong>FP16</strong>: FP16是一种半精度浮点格式，深度学习有使用FP16而不是FP32的趋势，因为较低精度的计算对于神经网络来说似乎并不重要。额外的精度没有任何作用，同时速度较慢，需要更多内存并降低通信速度。</li><li><strong>BFLOAT16</strong>: 由Google开发的16位浮点格式称为“Brain Floating Point Format”，简称“bfloat16”。这个名字来源于“Google Brain”，这是谷歌的一个人工智能研究小组。FP16设计时并未考虑深度学习应用，其动态范围太窄。BFLOAT16解决了这个问题，提供与FP32相同的动态范围。其可以认为是直接将FP32的前16位截取获得的，现在似乎也有取代FP16的趋势。</li></ul><div class="callout" data-callout="info"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-info"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></div><div class="callout-title-inner">回顾</div></div><div class="callout-content"><p>对于FP32，指数位为采用偏移指数 E_actual = E - 127, 此外E=0(表示0和非规格化数)和E=255(表示无穷大和NaN)被留作特殊用途<br>尾数位可以节省一个bit，因此可以达到M+1的精度</p></div></div><ul><li>所以计算FP32的最大正数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.</mn><munder><munder><mn>1111...1</mn><mo stretchy="true">⏟</mo></munder><mrow><mn>23</mn><mi mathvariant="normal">个</mi><mn>1</mn></mrow></munder><mo>×</mo><msup><mn>2</mn><mrow><mn>254</mn><mo>−</mo><mn>127</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>23</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>127</mn></msup><mo>≈</mo><mn>3.4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>38</mn></msup></mrow><annotation encoding="application/x-tex">1.\underbrace{1111...1}_{23个1}\times2^{254-127}=(1+1-2^{-23})\times2^{127}\approx3.4\times10^{38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.943548em;vertical-align:-1.299108em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6444400000000001em;"><span style="top:-1.700892em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span><span class="mord cjk_fallback mtight">个</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000000000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64444em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width="400em" height="0.548em" viewbox="0 0 400000 548" preserveaspectratio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg width="400em" height="0.548em" viewbox="0 0 400000 548" preserveaspectratio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg width="400em" height="0.548em" viewbox="0 0 400000 548" preserveaspectratio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.299108em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">4</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251016144207.png" alt="img" width="392px"></p><h3 id="122-量化类型"><a class="markdownIt-Anchor" href="#122-量化类型"></a> 1.2.2. 量化类型</h3><p><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251016151703.png" alt="img" width="310px"></p><ul><li><strong>对称量化</strong>: <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251016151533.png" alt="img" width="270px"><ul><li><strong>放缩因子</strong>: 在8bit量化中,我们用的范围是 -127到127。根据最大绝对值来确定缩放因子。这里最大绝对值α = 8.58，量化位数（b）是8位，所以对称整数范围就是 -127到127。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mfrac><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><msub><mi>r</mi><mi>f</mi></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><msub><mi>q</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">s=\frac{max(|r_f|)}{q_{max}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.5191879999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03808em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.51308em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mopen mtight">(</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><strong>量化数值</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>=</mo><mi>c</mi><mi>l</mi><mi>a</mi><mi>m</mi><mi>p</mi><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mfrac><mi>r</mi><mi>s</mi></mfrac><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q=clamp(round(\frac{r}{s}), q_{min}, q_{max})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>反量化</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>r</mi><mo>^</mo></mover><mo>=</mo><mi>s</mi><mo>∗</mo><msub><mi>q</mi><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\hat{r}=s*q_{int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li>显然这样会损失一些精度</li></ul></li></ul></li><li><strong>非对称量化</strong><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251016152519.png" alt="img" width="243px"><ul><li><strong>量化因子</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mfrac><mrow><msub><mi>r</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>r</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><msub><mi>q</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>q</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">s=\frac{r_{max}-r_{min}}{q_{max}-q_{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2995389999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li><strong>计算零点</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>q</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>−</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mfrac><msub><mi>r</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mi>s</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z=q_{min}-round(\frac{r_{min}}{s})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></li><li><strong>量化数值</strong> : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>=</mo><mi>c</mi><mi>l</mi><mi>a</mi><mi>m</mi><mi>p</mi><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mfrac><mi>r</mi><mi>s</mi></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>z</mi><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q=clamp(round(\frac{r}{s}) + z, q_{min}, q_{max})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>反量化</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>r</mi><mo>^</mo></mover><mo>=</mo><mi>s</mi><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>q</mi><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{r}=s*(q_{int}-z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h3 id="123-量化方法"><a class="markdownIt-Anchor" href="#123-量化方法"></a> 1.2.3. 量化方法</h3><p><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251016162712.png" alt="img|img" width="604px"></p><h4 id="1231-后训练量化"><a class="markdownIt-Anchor" href="#1231-后训练量化"></a> 1.2.3.1. 后训练量化</h4><ul><li>weight-only <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251002201818.png" alt="img" width="474px"><ul><li>在解码阶段，延迟主要是受到权重张量加载影响。现有技术通过只量化权重来加速内存读取</li><li>涉及离线量化权重，然后将低精度权重反量化为FP16的格式进行计算</li><li><strong>8-bit 量化</strong>：<ul><li><strong>LLM.int8()</strong></li><li><strong>binary coding quantizaion(BCQ)</strong></li></ul></li><li><strong>low-bit量化</strong>：<ul><li><strong>GPTQ</strong>：</li><li><a href="https://zhuanlan.zhihu.com/p/697761176"><strong>AWQ</strong></a>:<ol><li><strong>权重并不是同等重要的</strong>，仅有0.1%-1%的小部分权重影响输出的精度，那么如何筛选权重呢<ul><li>随机挑选:</li><li>基于权重分布挑选：对于权重矩阵中的元素按照绝对值的大小由大到小排序，绝对值越大越显著，选择前0.1%-1%的元素作为显著权重</li><li><strong>基于激活值分布挑选</strong>权重: 所谓激活值就是 <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017111654.png" alt="img" width="510px"></li><li>作者对于三个方法均进行了试验：发现基于激活值分布挑选的方式相比FP16几乎没有精度损失，也就是说只需要把少量权重保持在FP16剩下的进行低bit量化</li><li>这里还有个细节：作者为了避免过于复杂，首先将激活值<strong>每一列求绝对值的平均</strong>，然后把<strong>平均值较大</strong>的一列视作<strong>显著通道</strong>，保留FP16精度 <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017112614.jpg" alt="img" width="531px"></li></ul></li><li><strong>量化对显著权重进行放大可以降低量化误差</strong><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017130741.jpg" alt="img"> 下面考虑一个权重元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>∈</mo><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">w\in \bf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017113819.png" alt="img"><img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017113758.jpg" alt="img" width="521px"> 注意到单独放缩权重的某个元素实际上大概率并不会影响权重矩阵中最大的值所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="normal">Δ</mi><mo mathvariant="normal">′</mo></msup><mo>≈</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta&#x27;\approx\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017113900.jpg" alt="img" width="535px"></li><li>寻找放缩系数<br>转化为一个优化问题 <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017132704.png" alt="img" width="535px">，为什么是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">diag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>？因为上面说了显著是一个列的行为<ul><li>由于这个优化函数是不可微的，所以这里采用近似梯度，并且定义了最优scale的搜索空间 <img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251017133151.png" alt="img" width="380px"> 其中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">s_{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是每个通道的平均激活值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 是一个超参数，我们可以在区间[0,1]中使用快速网格搜索来找到最优的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span></li></ul></li></ol></li></ul></li><li><strong>稀疏量化表示</strong>：</li></ul></li><li>Weight-Activation Quantization<img src="/2025/10/15/MoE%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D%E4%BB%A5%E5%8F%8A%E9%87%8F%E5%8C%96/Pasted image 20251002201844 1.png" alt="img" width="470px"><ul><li>再预填充阶段的延迟被高精度的CUDA核心的计算性能限制，未来解决这个挑战，现有的方法使用低精度的张量核心来计算量化的权重和激活值</li><li>Activations在线量化再每个GEMM操作前进行</li><li><strong>8-bit</strong> ：<ul><li><strong>ZeroQuant</strong>：</li><li><strong>SmoothQuant：</strong></li></ul></li><li><strong>Low-bit 量化</strong>：<ul><li><strong>RPTQ</strong></li><li><strong>LLM-FP4</strong></li><li><strong>outlier-victim pair</strong></li><li><strong>Low-rank compensation</strong></li></ul></li></ul></li></ul><h4 id="1232-量化感知训练"><a class="markdownIt-Anchor" href="#1232-量化感知训练"></a> 1.2.3.2. 量化感知训练</h4><ul><li><strong>BitNet</strong>：</li><li><strong>LLM-QAT</strong>：</li><li><strong>DeepSeek-V3</strong>：</li></ul><h2 id="13-剪枝"><a class="markdownIt-Anchor" href="#13-剪枝"></a> 1.3. 剪枝</h2><h3 id="131-结构化剪枝"><a class="markdownIt-Anchor" href="#131-结构化剪枝"></a> 1.3.1. 结构化剪枝</h3><h4 id="1311-预训练剪枝"><a class="markdownIt-Anchor" href="#1311-预训练剪枝"></a> 1.3.1.1. 预训练剪枝</h4><h4 id="1312-生成式剪枝"><a class="markdownIt-Anchor" href="#1312-生成式剪枝"></a> 1.3.1.2. 生成式剪枝</h4><h3 id="132-非结构化剪枝"><a class="markdownIt-Anchor" href="#132-非结构化剪枝"></a> 1.3.2. 非结构化剪枝</h3><h4 id="1311-预训练剪枝-2"><a class="markdownIt-Anchor" href="#1311-预训练剪枝-2"></a> 1.3.1.1. 预训练剪枝</h4><h4 id="1312-生成式剪枝-2"><a class="markdownIt-Anchor" href="#1312-生成式剪枝-2"></a> 1.3.1.2. 生成式剪枝</h4>]]></content>
      
      
      <categories>
          
          <category> llm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llm_infra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llm 基础知识</title>
      <link href="/2025/10/01/llm-basic/"/>
      <url>/2025/10/01/llm-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前置基础"><a class="markdownIt-Anchor" href="#1-前置基础"></a> 1. 前置基础</h1><h2 id="11-注意力机制"><a class="markdownIt-Anchor" href="#11-注意力机制"></a> 1.1 注意力机制</h2><h3 id="111-普通注意力机制"><a class="markdownIt-Anchor" href="#111-普通注意力机制"></a> 1.1.1 普通注意力机制</h3><ul><li>输入: (N，D) 的二维数组，其中 N 是序列的长度(token 数量)，D 是嵌入维度(token 的嵌入向量维度)<br><img src="/2025/10/01/llm-basic/640.webp" alt="img" width="200px"></li><li>注意力权重矩阵(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">W_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)<br><img src="/2025/10/01/llm-basic/640 3.webp" alt="img" width="600px"><ul><li>形状: (D, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mo stretchy="false">{</mo><mo>⋅</mo><mo stretchy="false">}</mo></mrow></msub></mrow><annotation encoding="application/x-tex">d_{\{\cdot\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">{</span><span class="mord mtight">⋅</span><span class="mclose mtight">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>)</li><li>除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>H</mi><mi>S</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{HS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> 是因为使得点积保持在可控的范围内, 否则他们会随着维度的大小而增长</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><msub><mi>d</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">d_{k}=d_{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">d_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可以不同</li></ul></li><li>Softmax<ul><li>对矩阵的每一行进行操作</li></ul></li></ul><h3 id="112-批注意力机制"><a class="markdownIt-Anchor" href="#112-批注意力机制"></a> 1.1.2 批注意力机制</h3><p><img src="/2025/10/01/llm-basic/640 4.webp" alt="img" width="200px"></p><ul><li>这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">W_k\  ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span> 的形状和上面是相同的</li></ul><div class="callout" data-callout="danger"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></div><div class="callout-title-inner">Danger</div></div><div class="callout-content"><p>注意力矩阵中 (R, C) 单元格的值越高, 就意味着这两个对应索引的 Token 之间的关系越强</p></div></div><h3 id="113-多头注意力"><a class="markdownIt-Anchor" href="#113-多头注意力"></a> 1.1.3 多头注意力</h3><p><img src="/2025/10/01/llm-basic/640 5.webp" alt="img" width="600px"></p><ul><li>现在的模型中, 通常由多个头, 每个头分别执行其注意力任务, 最终将这些结果连接起来, 并通过一个线性层</li></ul><h3 id="114-掩码注意力"><a class="markdownIt-Anchor" href="#114-掩码注意力"></a> 1.1.4 掩码注意力</h3><p>注意力模块可以用于编码器和解码器</p><ul><li>对于编码器的部分(适用于语言理解和翻译任务), 每个 Token 关注序列中的其他 token 是有意义的</li><li>对于解码器的部分(生成模型), 每个 token 关注序列中的其他 token 是作弊的</li><li>我们希望使用掩码来进行防止作弊, 总的来说就是注意力矩阵中的上三角部分全部应该置零<ul><li>也即在 softmax 操作之前把这些位置全部置为 <code>-np.inf</code></li></ul></li></ul><h3 id="115-交叉注意力"><a class="markdownIt-Anchor" href="#115-交叉注意力"></a> 1.1.5 交叉注意力</h3><p><img src="/2025/10/01/llm-basic/640 6.webp" alt="img" width="700px"></p><ul><li>一个序列的元素会关注另一个序列中的元素</li></ul><h3 id="116-跨头维度向量化"><a class="markdownIt-Anchor" href="#116-跨头维度向量化"></a> 1.1.6. 跨头维度向量化</h3><p><img src="/2025/10/01/llm-basic/640 7.webp" alt="img" width="200px"><br><img src="/2025/10/01/llm-basic/640 8.webp" alt="img" width="200px"></p><h2 id="12-transformer-架构"><a class="markdownIt-Anchor" href="#12-transformer-架构"></a> 1.2 Transformer 架构</h2><p><img src="/2025/10/01/llm-basic/Pasted image 20250926201844.png" alt="img" width="352px"><br><img src="/2025/10/01/llm-basic/Pasted image 20250926200710.png" alt="img" width="343px"></p><h3 id="121-输入"><a class="markdownIt-Anchor" href="#121-输入"></a> 1.2.1 输入</h3><ul><li>输入是一个词嵌入: 由单词 Embedding 和位置 embedding 相加得到<ul><li>其中单词 embedding 可以通过 Word2Vec, Glove 等预训练得到, 也可以在 Transformer 中训练得到</li><li>位置 embedding, 其中 pos 表示单词在句子中的位置, d 表示 pe 的维度, 2i 表示偶数维度, 2i+1 表示奇数维度<img src="/2025/10/01/llm-basic/Pasted image 20250926200312.png" alt="img" width="383px"></li></ul></li></ul><h3 id="122-encoder-结构"><a class="markdownIt-Anchor" href="#122-encoder-结构"></a> 1.2.2. Encoder 结构</h3><p>可以看到是由 <strong>Multi-Head Attention, Add &amp; Norm, Feed Forward, Add &amp; Norm</strong> 组成的</p><h4 id="1221-addnorm"><a class="markdownIt-Anchor" href="#1221-addnorm"></a> 1.2.2.1 Add&amp;Norm</h4><p><img src="/2025/10/01/llm-basic/Pasted image 20250926201117.png" alt="img" width="332px"><br>Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</p><h4 id="1222-feed-forward"><a class="markdownIt-Anchor" href="#1222-feed-forward"></a> 1.2.2.2. Feed Forward</h4><p>两层全连接<br><img src="/2025/10/01/llm-basic/Pasted image 20250926201316.png" alt="img" width="353px"></p><h3 id="123-decoder-结构"><a class="markdownIt-Anchor" href="#123-decoder-结构"></a> 1.2.3. Decoder 结构</h3><ul><li><strong>Masked-Multi-Head Attention, Add&amp;Norm, Multi-Head Attention, Add&amp;Norm, Feed Forward, Add&amp;Norm</strong></li></ul><h4 id="1231-第一个multi-head-attention"><a class="markdownIt-Anchor" href="#1231-第一个multi-head-attention"></a> 1.2.3.1. 第一个multi-Head Attention</h4><ul><li><strong>采用masked操作</strong></li><li>输入: 一个mask的词嵌入矩阵</li></ul><h4 id="1232-第二个multi-head-attention"><a class="markdownIt-Anchor" href="#1232-第二个multi-head-attention"></a> 1.2.3.2. 第二个multi-Head Attention</h4><ul><li>输入: Encoder的编码信息</li><li>根据 Encoder 的输出 <strong>C</strong>计算得到 <strong>K, V</strong>，根据上一个 Decoder block 的输出 <strong>Z</strong> 计算 <strong>Q</strong> (如果是第一个 Decoder block 则使用输入矩阵 <strong>X</strong> 进行计算)，后续的计算方法与之前描述的一致。(交叉注意力)</li></ul><h4 id="1233-softmax-预测输出单词"><a class="markdownIt-Anchor" href="#1233-softmax-预测输出单词"></a> 1.2.3.3. Softmax 预测输出单词</h4><p><img src="/2025/10/01/llm-basic/Pasted image 20250926202539.png" alt="img" width="343px"><br><img src="/2025/10/01/llm-basic/v2-0938aa45a288b5d6bef6487efe53bd9d_1440w.png" alt="img" width="339px"></p><h2 id="13-moe架构"><a class="markdownIt-Anchor" href="#13-moe架构"></a> 1.3. MoE架构</h2><ul><li><p><strong>稀疏MoE层</strong>: 代替传统Transformer架构中的前馈神经网络. MoE层包含若干专家, 每个专家本身是一个独立的神经网络. 在实际应用中通常是前馈神经网络, 也可能是更复杂的网络</p></li><li><p><strong>门控网络或者路由</strong>: 这个部分用于决定哪些Token (token) 被发送到哪个专家。例如，在下图中，“More”这个Token可能被发送到第二个专家，而“Parameters”这个Token被发送到第一个专家。有时，一个Token甚至可以被发送到多个专家。Token的路由方式是 MoE 使用中的一个关键点，因为路由器由学习的参数组成，并且与网络的其他部分一同进行预训练。<br><img src="/2025/10/01/llm-basic/Pasted image 20250926205233.jpg" alt="img" width="709px"></p></li><li><p><strong>训练挑战</strong>: 虽然 MoE 能够实现更高效的计算预训练，但它们在微调阶段往往面临泛化能力不足的问题，长期以来易于引发过拟合现象。</p></li><li><p><strong>推理挑战</strong>: MoE 模型虽然可能拥有大量参数，但在推理过程中只使用其中的一部分，这使得它们的推理速度快于具有相同数量参数的稠密模型。然而，这种模型需要将所有参数加载到内存中，因此对内存的需求非常高。以 Mixtral 8x7B 这样的 MoE 为例，需要足够的 VRAM 来容纳一个 47B 参数的稠密模型。<strong>之所以是 47B 而不是 8 x 7B = 56B，是因为在 MoE 模型中，只有 FFN 层被视为独立的专家，而模型的其他参数是共享的</strong>。此外，假设每个Token只使用两个专家，那么推理速度 (以 FLOPs 计算) 类似于使用 12B 模型 (而不是 14B 模型)，因为虽然它进行了 2x7B 的矩阵乘法计算，但某些层是共享的。</p></li></ul><h3 id="131门控函数"><a class="markdownIt-Anchor" href="#131门控函数"></a> 1.3.1门控函数</h3><p>为了专家的负载均衡以及稀疏性的平衡<br><img src="/2025/10/01/llm-basic/Pasted image 20250926210501.png" alt="img" width="264px"><br><img src="/2025/10/01/llm-basic/Pasted image 20250926210236.png" alt="img" width="285px"><br><img src="/2025/10/01/llm-basic/Pasted image 20250926210250 1.png" alt="img" width="534px"></p><h3 id="132-辅助损失"><a class="markdownIt-Anchor" href="#132-辅助损失"></a> 1.3.2. 辅助损失</h3><p>鼓励所有专家相同的重要性</p><h3 id="132-moe拓展的transformer"><a class="markdownIt-Anchor" href="#132-moe拓展的transformer"></a> 1.3.2. MoE拓展的Transformer</h3><p>当扩展到多个设备时，MoE 层在不同设备间共享，而其他所有层则在每个设备上复制。<br><img src="/2025/10/01/llm-basic/Pasted image 20250926210345.jpg" alt="img" width="760px"></p><ul><li><strong>随机路由</strong>: 在 Top-2 设置中，始终选择排名最高的专家，但第二个专家是根据其权重比例随机选择的。</li><li><strong>专家容量</strong>: 我们可以设定一个阈值，定义一个专家能处理多少Token。如果两个专家的容量都达到上限，Token就会溢出，并通过残差连接传递到下一层，或在某些情况下被完全丢弃</li></ul><h2 id="14-lora"><a class="markdownIt-Anchor" href="#14-lora"></a> 1.4 LoRA</h2><p>LORA(Low-Rank Adaptation，<strong>低秩适应</strong>)是一种模型的轻量<a href="https://so.csdn.net/so/search?q=%E5%BE%AE%E8%B0%83&amp;spm=1001.2101.3001.7020">微调</a>方法，通过向模型的部分层添加可训练的低秩矩阵模块，实现模型在特定任务上的能力调整，同时保持原模型参数不变。<br><img src="/2025/10/01/llm-basic/Pasted image 20251003143619.png" alt="img" width="659px"><br><img src="/2025/10/01/llm-basic/Pasted image 20251003143723.png" alt="img" width="674px"></p><h3 id="141-原理"><a class="markdownIt-Anchor" href="#141-原理"></a> 1.4.1. 原理</h3><p>LORA 的核心思想是: 在不修改模型参数的情况下，通过添加一个额外的可训练模块，对模型行为进行小范围、有针对性的调整。</p><p>LORA 的工作机制包括两个核心阶段</p><ul><li>微调阶段: 仅对低秩矩阵进行参数调整在大模型中，像注意力层的权重矩阵通常规模很大。如果直接对这些矩阵进行微调，不仅计算开销大，还容易破坏原有能力。<ul><li>保持原始参数矩阵W不变</li><li>在旁边引入两个较小的矩阵</li><li>将他们的乘积 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>W</mi><mo>=</mo><mi>B</mi><mtext> </mtext><mo>⋅</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Delta W=B\ \cdot A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 作为对于W的一个附加调整项, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>W</mi><mo>^</mo></mover><mo>=</mo><mi>W</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">\hat{W}=W+\Delta W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9467699999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></li><li>在训练过程中仅更新A和B的参数, 保持W的冻结状态</li></ul></li><li><strong>推理阶段</strong>: 在计算时叠加 LORA 模块<ul><li>当x经过线性层时使用带有LoRA调整项的权重 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>W</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{W}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9467699999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span></span></span></span></li></ul></li></ul><p><img src="/2025/10/01/llm-basic/Pasted image 20251003144355.png" alt="img" width="667px"></p>]]></content>
      
      
      <categories>
          
          <category> llm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llm infra调研与学习</title>
      <link href="/2025/10/01/llm/"/>
      <url>/2025/10/01/llm/</url>
      
        <content type="html"><![CDATA[<h1 id="2-llm推理优化"><a class="markdownIt-Anchor" href="#2-llm推理优化"></a> 2. LLM推理优化</h1><p>参考综述 <a href="https://arxiv.org/abs/2404.14294">A Survey on Efficient Inference for Large Language Models</a></p><p><img src="/2025/10/01/llm/Pasted image 20250928213237.png" alt="img" width="467px"></p><ul><li>LLMs typically demand higher computational cost, memory access cost and memory usage in their inference process (we will analyse the root causes in the Sec. 2.3), which deteriorates the efficiency indicators (e.g., latency, throughput, power consumption and storage) in the resource-constrained scenarios</li><li>效率指标：<strong>存储</strong>，<strong>延迟</strong>，<strong>吞吐量</strong>，能量和电源消耗  &lt;—将大大影响----  计算消耗，访存消耗，存储使用</li><li>推理低效的根本原因:<ul><li>模型大小: 极大影响计算消耗, 访存消耗和存储使用</li><li>注意力操作: 当输入增长时, 注意力计算成二次方增长 (矩阵计算)</li><li>解码过程: 在解码阶段, 模型权重将从chip HBM 加载到 GPU chip, 此外还有KV cache随着输入的增长也会导致内存碎片</li></ul></li></ul><h2 id="21-分类"><a class="markdownIt-Anchor" href="#21-分类"></a> 2.1. 分类</h2><p><img src="/2025/10/01/llm/Pasted image 20250929143713.png" alt="img" width="502px"></p><ul><li>加速推理方法的三个层次：数据层次优化，模型层次优化，系统层次优化<ul><li>数据层次优化：通过输入的prompt或者更好的组织输出内容<ul><li>不需要改变原始模型（可能需要添加辅助模型，但是开销相对于训练的损耗不值一提）</li></ul></li><li>模型层面的优化：设计模型框架或者压缩预训练模型<ul><li>前者需要costly预训练或者少量微调成成本来获得模型能力，而后者通常会损失模型性能</li></ul></li><li>系统层面的优化：优化推理引擎和服务系统。<ul><li>前者并不涉及高消耗的模型训练，而后者在模型性能上是无损的</li></ul></li></ul></li></ul><h2 id="22-系统层面的优化"><a class="markdownIt-Anchor" href="#22-系统层面的优化"></a> 2.2 系统层面的优化</h2><h3 id="221-推理引擎"><a class="markdownIt-Anchor" href="#221-推理引擎"></a> 2.2.1. 推理引擎</h3><p><img src="/2025/10/01/llm/Pasted image 20250929145332 1.png" alt="img" width="592px"></p><h4 id="2211-图和算子优化"><a class="markdownIt-Anchor" href="#2211-图和算子优化"></a> 2.2.1.1 🧐<strong>图和算子优化</strong></h4><ul><li><p><strong>运行时分析</strong>： 图15中的分析结果表明，注意力算子和线性算子共同主导运行时间，它们的总时长通常超过推理时长的75%，并且多种算子占用很小的运行时，碎片化了算子执行的时间线并且增加了CPU侧内核启动的损耗，因此现今优化的推理引擎实行了高度融合的算子<br><img src="/2025/10/01/llm/Pasted image 20250929145922 1.png" alt="img" width="605px"></p></li><li><p>注意力算子优化：</p><ul><li><code>FlashAttention</code> ： 将整个注意力操作融合成单个的并且存储高效的算子。将输入矩阵进行分块，消除完整数据加载的需求。</li><li><code>FlashDecodeing</code> ： 目标是最大化计算并行化对于解码。在解码过程中，Q矩阵退化为一批向量，这使得在并行度仅限于批大小维度的情况下，填充计算单元变得具有挑战性。FlashDecoding通过沿序列维度引入并行计算来解决这个问题，但是会引起softmax计算的损耗</li><li><code>FlashDecoding++</code>：oftmax中的最大值仅作为防止数据溢出的缩放因子。然而，动态最大值会带来显著的同步开销。此外，大量实验表明，在典型的LLM（如Llama2 [239]、ChatGLM [240]）中，超过99.99%的softmax输入都处于特定范围内。因此，FlashDecoding++提出基于预先统计信息来确定缩放因子。这消除了 softmax计算中的同步开销，使得后续操作能够与 softmax计算并行执行</li></ul></li><li><p>线性算子优化：</p><ul><li><code>General Matrix-Vector Multiplication (GEMV)</code>（tensorRT-LLM）</li><li><code>FlashDecoding++</code>：当工作负载变化时，存在两个挑战：并行度低和内存访问瓶颈<ul><li>采用精密的分块测率提高并行性以及利用双倍缓冲区技术来隐藏访存延迟</li><li>线性操作在传统llm中通常有固定的大小，建立启发式筛选机制：基于不同的输入大小动态的选择不同的线性算子<ul><li>动态算子选择包括：FastGEMV [244]、FlatGEMM以及 cuBLAS [242]、[243]库提供的 GEMM</li></ul></li></ul></li><li><code>MegaBlocks</code>：解决MoE FFN层优化。把MoE FFN计算形式化成块稀疏算子并且提出定制GPU核来加速</li></ul></li><li><p>图优化：</p><ul><li>内核融合<ul><li>减少内存访问</li><li>减轻内核启动损失</li><li>提高并行化</li></ul></li><li><code>FlashAttention</code>：融合注意力计算，减少访问注意力结果的损失</li><li><code>BytyTransformer</code> and <code>deepspeed</code>：融合轻量算子（如残差连接层，层归一化，激活函数）到先前的线性算子。</li><li>内核融合技术也被用于提高大语言模型（LLM）推理的利用率。查询（Query）、键（Key）和值（Value）矩阵的投影原本是三个独立的线性运算，现被融合为一个线性算子以部署在现代 GPU上。目前，内核融合技术已在 LLM推理实践中得到应用，高度优化的推理引擎在运行时仅使用少数融合内核。例如，在<code>FlashDecoding++</code> [231] 的实现中，一个 transformer块仅集成了七个融合内核。借助上述算子和内核融合优化，FlashDecoding++相较于 HuggingFace实现实现了高达4.86倍的加速。</li></ul></li></ul><h4 id="2212-推测解码投机解码"><a class="markdownIt-Anchor" href="#2212-推测解码投机解码"></a> 2.2.1.2. 🧐推测解码(投机解码)</h4><p>这种方法的核心思想包括使用一个较小的模型(称为草稿模型)来有效地预测几个后续令牌，然后使用目标大型语言模型并行验证这些预测。<br>该方法旨在使LLM能够在通常单次推理所需的时间内生成多个标记。<br><img src="/2025/10/01/llm/Pasted image 20250929161434 1.png" alt="img" width="481px"></p><ul><li>两个步骤<ul><li><strong>Draft Construction</strong>：部署草稿模型生成子序列tokens，并行地或者自回归的方式<ul><li>传统解码技术采用两种基础的采样策略：<ul><li><code>贪心采样</code>:在每个解码步骤中选择概率最高的标记以生成特定的输出序列<ul><li><code>BLockwise Parallel Decoding</code>：保证draft tokens 准确地匹配贪心采样生成的序列来保证输出token的等价性</li></ul></li><li><code>核采样</code>:从概率分布中采样标记，每次运行都会生成不同的标记序列<ul><li><code>Speculative Sampling</code>（投机采样）：保留输出分布的等价性<br><img src="/2025/10/01/llm/Pasted image 20250929163246.png" alt="img" width="444px"></li></ul></li></ul></li></ul></li><li><strong>Draft Verification</strong>： 部署目标模型计算单个LLM推理步中所有草稿tokens的条件概率，随后依次决定是否接受每个token是否接受。接受度代表每个推理步平均被接受的draft tokens的个数，被视作衡量推测解码算法的性能的重要指标<ul><li><code>Token tree verifier</code>：用树结构来表示draft token集，使用树注意力机制来执行验证过程<ul><li>被证明是有效的提高推测解码的性能的方法</li></ul></li></ul></li></ul></li><li>主要研究方向<ul><li><strong>设计更好的draft model</strong><ul><li><code>DistillSpec</code> [220]直接从目标LLM中蒸馏出一个更小的草稿模型。</li><li><code>SSD</code> [221]涉及从目标LLM中自动识别一个子模型（模型层的子集）作为草稿模型，从而无需单独训练草稿模型。</li><li><code>OSD</code> [222] 在在线LLM服务中动态调整草稿模型的输出分布，以匹配用户查询分布。它通过监控LLM拒绝的草稿令牌，并利用这些数据通过蒸馏来优化草稿模型，从而实现这一目标。</li><li><code>PaSS</code> [223]提出将目标LLM本身用作草稿模型，将可训练令牌（前瞻令牌）融入输入序列，以实现后续令牌的同时生成。</li><li><code>REST</code> [224]引入了一种基于检索的推测解码方法，采用非参数检索数据存储作为草稿模型</li><li><code>SpecInfer</code> [225]提出了一种集体增强调优技术，使一组草稿模型的输出分布与目标LLM的输出分布对齐。</li><li><code>Lookahead decoding</code>[228]涉及并行生成目标LLM的n元语法，以辅助生成草稿令牌。</li><li><code>Medusa</code> [48]专门微调LLM的多个头，用于生成后续草稿令牌。</li><li><code>Eagle</code> [229]采用一种名为自回归头的轻量级Transformer层，以自回归方式生成草稿令牌，并将来自目标LLM的丰富上下文特征整合到草稿模型的输入中。</li></ul></li><li><strong>设计更高效的draft construction 方式</strong><ul><li>传统方法通常会生成单一的草稿 token序列，这给验证带来了挑战。对此，Spectr[230]主张生成多个草稿 token序列，并采用 k顺序草稿选择技术对 k个序列同时进行验证。该方法利用推测采样，确保输出分布的等价性。</li><li>类似地，SpecInfer[225]也采用了类似的方法。然而，与 Spectr不同的是，SpecInfer 将草稿 token序列合并成一棵“token树”，并引入树注意力机制进行验证。这种策略被称为“token树验证器”。由于其有效性，token树验证器已被众多推测解码算法广泛采用[48], [224], [226], [229]。</li><li>除了这些研究外，阶段推测解码[226]和级联推测草稿生成（CS Drafting）[227]提出通过将推测解码直接集成到 token生成过程中来加速草稿构建。</li></ul></li></ul></li><li>效率分析<br><img src="/2025/10/01/llm/Pasted image 20251007214515.png" alt="img" width="800px"><ul><li><code>Eagle</code>：<ul><li>采用自回归方法，直接利用先前生成tokens</li><li>从原始llm的token和draft model中的token集成了丰富的特征，从而提高了推测解码的准确性</li></ul></li></ul></li><li>端到端加速通过这些方法通常会低于接受率。因为draft model的生成成本通常不能忽略</li></ul><h3 id="222-服务系统"><a class="markdownIt-Anchor" href="#222-服务系统"></a> 2.2.2. 服务系统</h3><p><img src="/2025/10/01/llm/Pasted image 20250929165422.png" alt="img" width="650px"></p><h4 id="2221-存储管理"><a class="markdownIt-Anchor" href="#2221-存储管理"></a> 2.2.2.1 存储管理</h4><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">S^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> : 预先为每个请求估计一个最大生成长度上界, 防止浪费预分配的空间<ul><li>但是如果不能得到连续的空间分配, 那么这个方法将会失效 (页面碎片)</li></ul></li><li><code>vllm</code> : 通过分页的方式存储 KV cache<ul><li>先分配一个尽可能大的存储空间, 分成相等大小的多个物理块, 当请求到来, vllm动态的非连续地映射生成的KV cache 到预先分配的物理块中</li></ul></li><li><code>LightLLM</code> : 使用更细粒度的方式存储KV cache<ul><li>LightLLM不再以块为单位，而是将单个token的KV缓存作为一个单元，从而使生成的KV缓存始终能填满预分配的空间。</li></ul></li></ul><div class="callout" data-callout="attention"><div class="callout-title"><div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-triangle"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></div><div class="callout-title-inner">分页与访存的平衡</div></div><div class="callout-content"><p>通过分页的方式虽然能减轻存储空间的浪费, 但是注意力算子在使用KV cache的时候需要繁琐的寻址 (而非连续的方式寻址)</p><blockquote><ol><li>PageAttention by vLLM : 存储的头部维度有16字节为K cache的连续向量</li><li>FlashInfer : 为KV缓存协调多样化的数据布局，并辅以适当设计的内存访问方案。注意力算子的优化与分页KV缓存存储相结合，仍是服务系统发展中的前沿挑战。</li></ol></blockquote></div></div><h4 id="2222-连续批处理"><a class="markdownIt-Anchor" href="#2222-连续批处理"></a> 2.2.2.2 连续批处理</h4><p>The request lengths in a batch can be different, leading to low utilization when shorter requests are finished and longer requests are still running</p><ul><li><code>ORCA</code> : 计算过程包含多个迭代过程, 每个迭代要么处在与填充阶段要么处于解码阶段.<ul><li>不同的请求可以在迭代层次被批处理</li><li>这个工作在迭代层次下批处理线性算子, 在序列的维度拼接不同的请求</li></ul></li><li><code>vLLM</code> ： 使得不同KV cache长度被批处理</li><li><code>Sarathi</code>， <code>DeepSpeed-FastGen</code> and <code>AsrathiServe</code> 引入了划分-融合（split-and-fuse）方法，来把预填充请求和解码请求批处理<ul><li>在序列维度划分长预填充请求，并且和多个短解码请求批处理</li><li>平衡不同迭代次数的工作负载，并且显著减少了尾延迟</li><li>Split-and-fuse 技术前提是在与填充阶段，请求可以被划分成离散的块。块填充方法论涉及在序列维度划分预填充请求</li></ul></li></ul><h4 id="2223-调度策略"><a class="markdownIt-Anchor" href="#2223-调度策略"></a> 2.2.2.3 🧐<strong>调度策略</strong></h4><ul><li><code>Head-of-line blocking</code>（队头阻塞） 在长请求被赋予优先时发生<ul><li>具体而言，内存使用量会随着长请求的增加而迅速增长，当系统耗尽内存容量时，会阻碍后续请求的处理</li></ul></li><li><code>vLLM</code>和<code>LightLLM</code>使用的是简单的first come first serve的原则</li><li><code>DeepSpeed-FastGen</code> 优先处理解码请求</li><li><code>FastServe</code> 提出一个优先调度策略优化对头阻塞问题，实现low job completion time<ul><li>采用多级反馈队列</li><li>对于解码阶段，由于位置的请求长度，先预测长度以及使用skip-join 的方式找到合适的优先级</li></ul></li><li><code>VTC</code> 讨论公平性。<ul><li>引入一个基于token数量的成本函数，来衡量公平性，并且采用公平调度的方式来保证公平性</li></ul></li></ul><h4 id="2224-分布式系统"><a class="markdownIt-Anchor" href="#2224-分布式系统"></a> 2.2.2.4. 分布式系统</h4><p>由于预填充阶段是计算密集的，解码阶段是存储密集的。</p><ul><li><code>Split-wise</code>和 <code>TetriInfer</code> 和 <code>DistServe</code> 证明了将请求的预填充和解码步骤分离的高效性</li><li><code>SpotServe</code> ：抢占式GPU实例。解决了动态并行控制和示例迁移</li><li><code>Infinite-LLM</code> 将分页KV cache 方法拓展到分布式云环境</li></ul><h3 id="223-llm-框架对比"><a class="markdownIt-Anchor" href="#223-llm-框架对比"></a> 2.2.3. LLM 框架对比</h3><p><img src="/2025/10/01/llm/Pasted image 20251002155532.png" alt="img" width="694px"></p><ul><li>结果显示：<code>FlashDecoding++</code> 和 <code>TensorRT-LLM</code> 推理速度表现得比其他的方法更出色</li></ul><h3 id="224-未来的方向以及一些建议"><a class="markdownIt-Anchor" href="#224-未来的方向以及一些建议"></a> 2.2.4. 未来的方向以及一些建议</h3><p>系统级优化在提高效率的同时不会降低准确性，因此在LLM推理实践中变得普遍。推理优化也适用于服务。最近，算子优化与实际服务场景紧密结合，例如，RadixAttention[50]是专为前缀缓存设计的，tree attention[225]用于加速推测解码验证。应用和场景的迭代将继续对算子开发提出新的要求。鉴于实际服务系统中固有的多方面目标，如作业完成时间、系统吞吐量和公平性，调度策略的设计相应地变得复杂。在LLM服务领域，请求长度不确定，现有文献通常依靠预测机制来辅助调度策略的设计。然而，当前预测器[248]的效果未达到理想标准，表明服务调度策略的开发仍有改进和优化的潜力</p><h2 id="23-模型层次的优化"><a class="markdownIt-Anchor" href="#23-模型层次的优化"></a> 2.3. 模型层次的优化</h2><h3 id="231-高效结构设计"><a class="markdownIt-Anchor" href="#231-高效结构设计"></a> 2.3.1. 🧐高效结构设计</h3><p><img src="/2025/10/01/llm/Pasted image 20251002173118.png" alt="img" width="691px"></p><h4 id="2311-高效ffn设计"><a class="markdownIt-Anchor" href="#2311-高效ffn设计"></a> 2.3.1.1. 高效FFN设计</h4><ul><li><strong>专注于优化专家权重的获取过程以及使得这些专家更加轻量化</strong><ul><li><code>MoEfication</code> ：将一个非MoE LLM通过预训练权重转换为一个MoE版本<ul><li>消除昂贵的对于MoE模型的预训练</li><li>将预训练大模型的FFN神经元划分为多个组，每个组的神经元同步的被激活函数激活</li><li>然后，重构每组神经元为一个专家</li></ul></li><li><code>Sparse Upcycling</code> ： 从密集模型的检查点直接初始化MoE-base LLM权重<ul><li>MoE-based LLM 中的专家是密集模型中的FFN的复制体</li></ul></li><li><code>MPOE</code>： 通过Matrix Product Operators decomposition （矩阵乘积算子分解）减少MoE-based LLMs的参数量<ul><li>分解每个FFN的权重矩阵为一个全局共享张量（包含全局信息以及一个捕获特殊特征的局部辅助张量的集合）</li></ul></li></ul></li><li><strong>设计路由模型</strong><ul><li><code>Switch Transformer</code>：引入一个额外的损失，称为负载平衡损失，用于惩罚路由模型的不均衡分配<ul><li>这个损失被形式化成token分配向量和一个均匀分布向量的点乘</li></ul></li><li><code>BASE</code>： 端到端地为每一个专家学习一个嵌入，将专家分配给和它的嵌入相似度高的token<ul><li>形式化了一个线性分配问题，并且使用拍卖算法高效解决这个问题</li></ul></li><li><code>Expert Choice</code>：<ul><li>每个专家通过嵌入相似性独立的选择top-K的tokens</li></ul></li></ul></li><li><strong>提升训练方法</strong><ul><li><code>SE-MoE</code>： 引入辅助损失，路由z-loss<ul><li>发现：由softmax 算子引入的指数函数会加剧舍入误差，并导致训练不稳定。</li><li>Z-loss惩罚输入到指数函数中的大logits，最小化每轮的舍入误差</li></ul></li><li><code>StableMoE</code>： 指出路由波动问题，导致专家分配在训练和推理阶段的不一致性<ul><li>对于相同的输入token，在训练时被分配给不同的专家，但是在推理时只分配一个专家</li><li>首先，学习一个路由策略，并且使得它在骨干网络和推理阶段固定</li></ul></li><li><code>SMoE-Dropout</code>：在训练过程中，逐渐在增加激活的专家个数</li><li><code>GLaM</code>： 预训练并发布了一些系列带有不同参数量的模型，并且对比了他们和密集型LLM在few-shot 任务上的性能</li><li><code>Mixtral 8 $\times$ 7B</code>: 是一个开源的模型. 在推理阶段, 它使用13b激活参数, 并且对比LLaMA-2-70B模型实现了更好的性能<ul><li>每一层由8个FFN专家, 并且在推理时每个token被分配给2个专家</li></ul></li></ul></li></ul><h4 id="2312-高效注意力设计"><a class="markdownIt-Anchor" href="#2312-高效注意力设计"></a> 2.3.1.2. 高效注意力设计.</h4><ul><li><code>Multi-Query Attention</code>:<ul><li>（MQA）共享KV cache 在多个注意力头之间，同时保留不同的Q矩阵</li><li><code>Grouped-query attention</code>（GQA）： 把多个注意力头分组，对于每个组存储一个简单的KV cache。</li></ul></li><li><code>Low-Complexity Attention</code>：<ul><li><code>Kernel-based Attention</code>： kernel <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span> , 用一个核transformer特征映射 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>K</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\phi(Q)\phi(K)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 线性点乘, 近似非线性的softmax算子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal"><mi mathvariant="normal">S</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Q</mi><msup><mi mathvariant="normal">K</mi><mi mathvariant="normal">T</mi></msup><mo stretchy="false">)</mo></mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{Softmax(QK^T)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">t</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span><span class="mord mathrm">(</span><span class="mord mathrm">Q</span><span class="mord"><span class="mord mathrm">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">T</span></span></span></span></span></span></span></span><span class="mord mathrm">)</span></span></span></span></span><ul><li>它通过先计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>K</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi(K)^TV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 再与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span> 相乘从而避免了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 的传统二次计算量</li><li>Linear Transformer: 它采用了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">elu</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\phi(x)= \operatorname{elu}(x)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">u</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 作为核函数</li><li>Performers 以及 RFA 提出了使用随机特征投影来更好地近似softmax函数</li><li>PolySketchFormer 使用了多项式函数以及草图技术来近似softmax函数</li></ul></li><li><code>Low-Rank Attention</code> : 使用了,将KV矩阵的token维度压缩为一个固定的, 更小的长度<ul><li>主流的研究 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msup><mo>→</mo><msup><mi>X</mi><mo mathvariant="normal">′</mo></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>k</mi><mo>×</mo><mi>d</mi></mrow></msup><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>X</mi><mi mathvariant="normal">是</mi><mi>K</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">X\in\mathbb{R}^{n\times d }\to X&#x27;\in\mathbb{R}^{k\times d},其中X是K或者V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></li><li>其他研究: 采用线性投影压缩token维度, 对于KV矩阵分别乘以投影矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">P_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">P_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><code>Linformer</code>: 首先提出并分析attention 映射的低秩特性.</li><li><code>LRT</code>: 提出同时使用低秩transformer于注意力块, FFN</li><li><code>FLuRKA</code>: 结合低秩transformer以及核化的注意力矩阵<ul><li>首先减少KV矩阵的token维度, 然后采用核方法于Q和低秩的K</li></ul></li></ul></li><li><code>Luna</code> 以及<code>Set Transformer</code> 使用更小的queries 来压缩K和V矩阵<ul><li>Luna涉及额外的query矩阵有固定的长度k.<ul><li>更小的query于原始的上下文矩阵做注意力操作称为 pack attention, 将上下文矩阵压缩到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mrow><mi>k</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{k\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></li><li>相似的, 采用原始的Q矩阵和压缩的KV矩阵做注意力, 称为unpack attentioin</li><li>额外的quey矩阵可以是科学系的参数或者从前面的层中获得</li></ul></li><li>Set Transformers: 引入长度固定的 inducing points 向量</li><li>Funnel Tansformer 使用pooling算子来逐渐压缩Q矩阵的序列长度</li></ul></li></ul></li></ul><h4 id="2313-替代transformer"><a class="markdownIt-Anchor" href="#2313-替代transformer"></a> 2.3.1.3. 🧐替代Transformer</h4><p>在该研究领域内，两个突出的研究方向受到了广泛关注。</p><ul><li>其中一个研究方向专注于<strong>状态空间模型</strong>（State Space Model, SSM），该模型基于HiPPO理论[62]将序列建模表述为一种<strong>递归变换</strong>。<ul><li>与基于注意力的Transformer相比，SSM在输入序列长度方面表现出线性计算和内存复杂度，这增强了其在处理长上下文序列时的效率。在本综述中，SSM指的是满足以下两个特性的一系列模型架构：<ol><li>它们基于HiPPO[62]和LSSL[63]提出的以下公式对序列进行建模:<br><img src="/2025/10/01/llm/Pasted image 20251007220320.png" alt="img" width="200px">其中，A、B和C表示转移矩阵，x表示中间状态，u表示输入序列。</li><li>他们基于HiPPO理论[62]设计了转移矩阵A。具体来说，HiPPO提出通过将输入序列投影到一组多项式基上，将其压缩为一系列系数（即状态）。</li></ol></li><li>多项研究致力于<strong>改进转移矩阵A的参数化或初始化</strong>。这涉及到在状态空间模型（SSM）中优化矩阵的构建或初始化方式，以增强其在序列建模任务中的有效性和性能。<ul><li><code>LSSL</code> [63]首先提出使用HiPPO设计的最优转移矩阵HiPPO-LegS对A进行初始化。<br><img src="/2025/10/01/llm/Pasted image 20251007221325.png" alt="img" width="500px"></li><li>然而，计算该卷积核的成本很高，因为它需要多次与A相乘。为此，<code>S4</code> [64]、<code>DSS</code> [65] 和 <code>S4D</code> [66]提出对矩阵A进行对角化处理，从而加快计算速度。这可视为对转移矩阵A的一种参数化技术。</li><li>早期的SSM对每个输入维度独立处理，导致可训练参数数量庞大。为提高效率，<code>S5</code> [70]提出使用单组参数同时处理所有输入维度。基于此结构，S5引入了一种基于标准HiPPO矩阵的A参数化和初始化方法。</li><li><code>Liquid S4</code> [69] 和<code>Mamba</code> [73]则以输入依赖的方式对转移矩阵进行参数化，进一步增强了SSM的建模能力。此外，<code>S5</code> [70] 和<code>Mamba</code> [73]均采用并行扫描技术，无需卷积操作即可实现高效的模型训练。该技术在现代GPU硬件上的实现和部署具有优势。</li></ul></li><li>另一类研究旨在基于状态空间模型（SSMs）<strong>设计更好的模型架构</strong>。<ul><li><code>GSS</code> [67] 和 <code>BiGS</code> [72] 将门控注意力单元（GAU）[102]与状态空间模型相结合。具体来说，它们将门控注意力单元中的注意力操作替换为状态空间模型操作。</li><li><code>BST</code> [71] 将状态空间模型与所提出的块Transformer相结合，后者引入了强大的局部归纳偏置。</li><li><code>H3</code> [68]观察到状态空间模型在回忆早期标记和比较序列中的标记方面存在不足。为此，它建议在标准状态空间模型操作之前添加一个移位状态空间模型操作，用于将输入标记直接移位到状态中。</li><li><code>MambaFormer</code> [74] 通过将Transformer中的前馈网络（FFN）层替换为状态空间模型层，将标准Transformer与状态空间模型相结合。</li><li><code>Jamba</code> [103]引入了另一种结合Transformer和状态空间模型的方法，即在状态空间模型中添加四个Transformer层。</li><li><code>DenseMamba</code>[104]探讨了传统状态空间模型中隐藏状态退化的问题，并在状态空间模型架构中引入密集连接，以在模型更深层保留细粒度信息。</li><li><code>BlackMamba</code> [105] 和 <code>MoE-Mamba</code> [106]提出使用混合专家（MoE）技术增强状态空间模型，以在保持模型性能的同时优化训练和推理效率。</li></ul></li></ul></li><li>此外，其他研究主要侧重于采用<strong>长卷积或设计类注意力公式来对序列进行建模</strong>状态空间模型。<br><img src="/2025/10/01/llm/Pasted image 20251007220518.png" alt="img" width="800px"></li></ul><h3 id="232-模型压缩"><a class="markdownIt-Anchor" href="#232-模型压缩"></a> 2.3.2. 模型压缩</h3><p><img src="/2025/10/01/llm/Pasted image 20251002201410.png" alt="img" width="686px"></p><h4 id="2321-量化"><a class="markdownIt-Anchor" href="#2321-量化"></a> 2.3.2.1 量化</h4><p>将模型权重和激活从<strong>高位宽变为低位宽</strong><br><img src="/2025/10/01/llm/Pasted image 20251002201254 1.png" alt="img" width="364px"></p><ul><li>效率分析：<ul><li><p>再预填充阶段的延迟被高精度的CUDA核心的计算性能限制，未来解决这个挑战，现有的方法使用低精度的张量核心来计算量化的权重和激活值</p><ul><li>Weight-Activation Quantization ： Activations 在线量化再每个GEMM操作前进行<br><img src="/2025/10/01/llm/Pasted image 20251002201844 1.png" alt="img" width="470px"></li></ul></li><li><p>相反，在解码阶段，延迟主要是受到权重张量加载影响。现有技术通过只量化权重来加速内存读取</p><ul><li>Weight-only Quantization： 涉及离线量化权重，然后将低精度权重反量化为FP16的格式进行计算<br><img src="/2025/10/01/llm/Pasted image 20251002201818.png" alt="img" width="474px"></li></ul></li></ul></li></ul><h5 id="23211-后训练量化"><a class="markdownIt-Anchor" href="#23211-后训练量化"></a> 2.3.2.1.1. 后训练量化</h5><p>对于训练模型进行量化，无需重新训练，可能是一个开销大的过程</p><ul><li>Weight-only 量化：<ul><li><code>GPTQ</code>：<ul><li>在传统的OBQ算法上进行构建<ul><li>OBQ利用权重矩阵每行的最优量化顺序，该顺序由相对于未量化权重的 Hessian矩阵的重建误差指导。</li><li>在每个量化步后，OBQ迭代的调整未量化的权重来减少重构误差</li><li>然而频繁的更新海森矩阵增加了计算复杂度</li></ul></li><li>GPTQ通过采用统一的从左到右顺序对每一行进行量化，从而简化了这一过程，避免了大量Hessian矩阵更新的需求。该策略通过仅在量化一行时计算海森矩阵，然后将计算结果用于后续行，从而显著降低了计算需求，加快了整体量化过程。</li></ul></li><li><code>LUT-GEMM</code>：提出一个新的反量化方法<ul><li>使用查找表来减少反量化的损失</li><li>非均匀的量化方法，称为Binary-Codeing Quantization（BCQ</li></ul></li><li><code>AWQ</code>： 权重通道对于性能的影响不同，特别强调那些与激活中表现出异常值的输入通道对齐的权重通道<ul><li>采用重参数化方法：通过网格搜索选择重参数化系数，最小化重构误差</li></ul></li><li><code>OWQ</code>：观察到量化的困难度与激活值的离群点有关。<ul><li>采用混合精度量化策略：找到权重矩阵中的弱列，分配高精度给这些特殊的权重并且为剩下的权重分配较低的精度水平</li></ul></li><li><code>SpQR</code>：引入了一个方法论：识别权重离群值，并且分配高精度，剩下的被量化到3bit</li><li><code>SqueezeLLM</code>： 在全精度稀疏矩阵中存储离群值，并且采用非均匀的量化方式量化剩下的权重</li><li><code>QuIP</code>：引入LDLQ<ul><li>一个最优自适应方法解决二次代理目标</li><li>研究表明保证权重和海森矩阵之间的不相关性能提高LDLQ的效率<ul><li>采用随机正交矩阵乘法来实现不相关性</li></ul></li></ul></li><li><code>FineQuant</code>：使用启发式的方法来决定每列的量化粒度，结合实验中获得的经验来设计量化方案</li><li><code>QuantEase</code>：在GPTQ上构建<ul><li>当量化每一层使用坐标下降更精确地补偿未量化的权重</li><li>可以使用GPTQ做初始化以及进一步优化补偿过程</li></ul></li><li><code>LLM-MQ</code>：用FP16的格式保护权重离群值，并且把他们存储在压缩稀疏列格式（CSR）<ul><li>将每层的位宽分配建模为整数规划问题，并采用高效求解器在几秒内完成求解</li><li>设计高效CUDA核心来集成反量化算子</li></ul></li></ul></li><li>Weight-activation 量化<ul><li><code>Zeroquant</code>：采用核融合来最小化访存消耗，并进行逐层知识蒸馏来恢复其性能</li><li><code>FlexGen</code>：直接量化权重核KV cache 到INT4 来减少大批量推理过程中的内存占用</li><li><code>LLM.Int8</code>： LLM.int8() [194]发现激活值中的异常值集中在一小部分通道内。利用这一见解，LLM.int8() 根据输入通道内的离群值分布将激活和权重分为两个不同的部分，以最小化激活中的量化误差<ul><li>带有离群值的部分使用FP16的格式进行存储，其他的则以INT8进行存储</li></ul></li><li><code>SmoothQuant</code> 采用重参数化的方法解决量化激活值的挑战<ul><li>该方法引入了一个缩放因子，它在扩大权重通道数据范围的同时，缩小了相应激活通道的数据范围。</li></ul></li><li><code>ZeroQuant</code>：权重每组量化以及激活token量化。<ul><li>ZeroQuantV2： 采用LoRC（Low-Rank Compensation），使用低秩矩阵来减少量化的不准确性</li></ul></li><li><code>RPTQ</code>：发现不同激活通道的分布存在显著差异，这给量化带来了挑战。为缓解此问题，RPTQ将具有相似激活分布的通道重组为簇，并在每个簇内独立应用量化。</li><li><code>OliVe</code>：观察到离群值附近的正常值不太重要。因此，它将每个离群值与一个正常值配对，牺牲后者以实现离群值更广泛的表示范围。</li><li><code>OS+</code> ： 每通道偏移和放缩</li><li><code>ZeroQuant-FP</code>:研究表明，将激活值量化为浮点类型（FP4和FP8）比整数类型产生更好的结果</li><li><code>Omniquant</code>:它优化权重裁剪的边界和等效变换的缩放因子，以最小化量化误差。</li><li><code>QLLM</code>: 通过实施通道重组解决了异常值对量化的影响，引入了可学习的低秩参数来最小化量化误差</li><li><code>Atom</code>：涉及激活的混合精度以及动态量化<ul><li>拓展了KV cache 的量化方法到INT4</li></ul></li><li><code>LLM-FP4</code>： 将整个模型量化到FP4的格式并且引入预偏移指数偏置技术。该方法将激活值的缩放因子与权重相结合，以解决离群值带来的量化挑战。</li><li><code>BiLLM</code>： BiLLM[203]是迄今为止最低比特PTQ研究之一。BiLLM发现权重呈钟形分布，且权重的海森矩阵具有异常长的尾部分布。基于此，它提出根据海森矩阵将权重从结构上分为显著值和非显著值，并对它们分别进行二值化。因此，BiLLM可以将大型语言模型广泛量化至1.08比特，且不会导致困惑度显著下降。</li><li><code>KVQuant</code>：提出了一个非均匀的量化方法for KV cache。<ul><li>通过在校正集上离线获得最优的数据形式</li></ul></li><li><code>KIVI</code>： 提出了一种不需要调整的2bit KV cache 量化算法<ul><li>对key cache进行每个通道的量化，以及对于value cache进行每个token的量化，通过group-wise的方式</li></ul></li><li>Li et al.</li></ul></li></ul><h5 id="23212-量化感知训练"><a class="markdownIt-Anchor" href="#23212-量化感知训练"></a> 2.3.2.1.2. 量化感知训练</h5><p>将量化的影响融入模型训练的过程中，通过集成模拟量化效果的层，这种方法有助于权重适应量化引起的误差，从而提升任务性能</p><ul><li><p>为了减少数据的需求</p><ul><li><code>LLM-QAT</code>：<ul><li>引入了一种不需要数据的方法：通过使用原始的FP16  LLMs来生成训练数据</li><li>具体而言，LLM-QAT将分词词汇表中的每个标记作为起始标记来生成句子。</li><li>基于生成的训练数据，LLM-QAT采用基于蒸馏的工作流程来训练量化的 LLM，使其匹配原始 FP16 LLM 的输出分布</li></ul></li><li><code>Norm Tweaking</code>：<ul><li>将起始标记的选择限制为仅在比例最高的顶级语言类别中列出的那些语言类别。这种策略可以有效提高量化模型在不同任务上的泛化能力</li></ul></li></ul></li><li><p>为了减少计算成本，很多方法采用参数效率调整策略（PEFT）来加速QAT</p><ul><li><code>QLoRA</code>：将权重量化到4bit，然后针对每个4位权重矩阵采用BF16精度的LoRA来微调量化模型<ul><li>允许在只是用30GB的GPU存储来完成65B的参数高效微调</li></ul></li><li><code>QALoRA</code>： 将分组量化和QLoRA结合<ul><li>由于QLoRA的量化参数量小于LoRA的参数，导致量化与低秩自适应的不平衡，于是采用分组来解决这个问题</li><li>可以把LoRA项融入量化权重矩阵</li></ul></li><li><code>LoftQ</code>：使用原始FP16权重矩阵和量化后权重矩阵的差异的奇异值分解，初始化LoRA矩阵<ul><li>实现更精确对于原始权重的估计</li></ul></li><li><code>Norm Tweaking</code>： 提出在量化后训练LayerNorm层，并使用知识蒸馏使量化模型的输出分布与FP16模型匹配，实现类似于LLM-QAT的效果，同时避免高昂的训练成本。</li></ul></li></ul><h5 id="23213-对比试验和分析"><a class="markdownIt-Anchor" href="#23213-对比试验和分析"></a> 2.3.2.1.3. 对比试验和分析</h5><blockquote><p>试验设置：采用了 weight-only 的量化方法（AWQ），使用LLaMA-2-7B 和 LLaMA-2-13B以及TensorRT-LLM以及LMDeploy推理框架</p></blockquote><ol><li>Weight-only 量化能大大加速解码阶段，这种增强主要源于更快速地从HBM加载低精度的权重</li><li>对于预填充阶段，weight-only量化可能会增加延迟，这是因为与填充阶段的瓶颈是计算消耗而不是存储消耗</li><li>随着batch size和输入长度的增长，weight-only量化的加速程度将逐渐消失<ul><li>因为batch size和输入长度变大的时候，计算开销会增加，此时计算开销将会占主导，而访存开销将会降低</li></ul></li><li>Weight-only 量化由于能显著降低访存开销而对于LLM大有脾益</li></ol><h4 id="2322-稀疏化"><a class="markdownIt-Anchor" href="#2322-稀疏化"></a> 2.3.2.2. 稀疏化</h4><p>这个方法只在通过高效忽略零元素，降低计算的复杂度和内存使用<br>通常被使用在权重参数和注意力激活</p><h5 id="23221-权重剪枝"><a class="markdownIt-Anchor" href="#23221-权重剪枝"></a> 2.3.2.2.1. 权重剪枝</h5><p><img src="/2025/10/01/llm/Pasted image 20251003124048.png" alt="img" width="500px"><br>去除不那么重要的结构和权重，在不损失太多模型性能地在预填充和解码阶段降低计算和存储开销、</p><ul><li>Unstructred pruning<ul><li>以细粒度剪枝单个权重值，对比结构化剪枝，他能实现更好的稀疏化，然而获得的稀疏模式缺乏高阶的规律性</li><li>可能会导致不规则的访问内存以及计算模式，可能会导致硬件加速受阻<ul><li>重构误差<ul><li><code>SparseGPT</code>： 它集成OBS的思想：考虑移除每一个权重的网络重构误差<ul><li>OBS迭代地决定剪枝mask剪枝，并且重构未剪枝的权重来补偿剪枝的损失</li><li>通过Optimal Partial Update 技术来改进OBS</li></ul></li><li><code>Prune and Tune</code>：在SparseGPT上微调LLM</li><li><code>ISC</code>：结合OBS和OBD的标准</li><li><code>BESA</code>：通过重构误差的梯度下降来学习一个可微的二元掩码<ul><li>剪枝率有最小化重构误差决定</li></ul></li></ul></li><li>基于幅度<ul><li><code>Wanda</code>：提出将权重大小与输入激活范数之间的逐元素乘积用作剪枝准则</li><li><code>RIA</code>：通过使用相对重要性和激活度指标共同考虑权重和激活值，该指标基于每个权重元素的所有连接权重来评估其重要性。</li><li><code>OWL</code>：专注于决定每一层的剪枝率</li></ul></li></ul></li></ul></li><li>Structured pruning<ul><li>剪枝一整个通道或者层，操作的粒度更粗</li><li>这些方法在传统硬件平台上能促进推理的加速</li><li>然而粗粒度通常会较大影响模型的性能</li><li><code>LLM-pruner</code>：提出一种任务无关的剪枝方法<ul><li>具体来说，它首先基于神经元之间的连接依赖关系识别大型语言模型中的耦合结构。</li><li>然后，它基于精心设计的组级剪枝指标决定移除哪些结构组。</li><li>剪枝后，它进一步提出通过一种参数高效的训练技术，即LoRA等，来恢复模型性能</li></ul></li><li><code>Shared LLaMA</code>：提出将原始大语言模型剪枝为现有预训练大语言模型的特定目标架构<ul><li>此外，它提出动态批加载技术</li></ul></li><li><code>ZipLM</code>：</li><li><code>LoRAPrune</code>：剪枝带有LoRA模块的预训练LLM。</li><li><code>LoRAShear</code>：</li><li><code>SliceGPT</code>：基于RMSNorm运算的计算不变性理念</li><li><code>PLATON</code>：提出剪枝时同时考虑他们的重要性和不确定性，它使用重要性分数的指数移动平均（EMA）来估计重要性，并采用上置信界（UCB）来表示不确定性</li><li><code>SIMPLE</code>：通过学习对应的稀疏掩码来进行注意力头，FFN神经元和隐藏维度的剪枝<ul><li>剪枝后使用知识蒸馏来进行模型性能恢复</li></ul></li></ul></li><li>Sparse Attention：<br><img src="/2025/10/01/llm/Pasted image 20251003133231.png" alt="img" width="417px"><ul><li><strong>Static sparse attention</strong>：独立于输入移除激活值。这些方法预先定义稀疏注意力掩码。<ul><li>最常见的是局部注意力以及全局注意力模式<ul><li>局部注意力模式：使用固定大小的窗口注意力捕捉局部上下文</li><li>全局注意力模式：模式通过计算并关注序列中的所有标记，捕获特定标记与所有其他标记的相关性。</li></ul></li><li><code>Sparse Transformer</code>：结合这些模式，用局部模式捕捉局部上下文，然后每隔几个词用全局模式聚合信息</li><li><code>StreamingLLM</code>：</li><li><code>BigBird</code>：使用随机模式，局部模式、全局模式和随机模式的组合被证明能够封装所有连续的序列到序列函数，这证实了其图灵完备性。</li><li><code>Longformer</code>：膨胀滑动窗口模式，它类似于膨胀卷积神经网络，使滑动窗口“膨胀”以增加感受野。</li><li><code>Structured Sparse Attention</code> ：提出了一种熵感知训练方法，该方法将高概率注意力值聚集到更密集的区域。</li><li><code>SemSA</code>：采用基于梯度的剖析方法识别重要的注意力模式，并自动优化注意力密度分布，以进一步提升模型效率。</li></ul></li><li><strong>Dynamic sparse attention</strong>：对不同的输入会自适应地去除激活值，通过实时监测神经元激活值来绕过影响可忽略的神经元的计算，从而实现剪枝。<ul><li><code>Token-pruning</code>：Spatten等[153]、SeqBoat等[154]和Adaptively Sparse Attention等[155]利用语言结构中固有的冗余性，提出了动态令牌级剪枝策略。<ul><li><code>Spatten</code>等[153]通过聚合注意力矩阵列来评估每个词的累积重要性，随后在后续层中从输入中剪枝累积重要性最小的令牌。</li><li><code>SeqBoat</code>等[154]使用稀疏sigmoid函数训练线性状态空间模型（SSM），以确定每个注意力头要剪枝的令牌。Spatten和SeqBoat都会对整个输入中无信息的令牌进行剪枝。</li><li><code>Adaptively Sparse Attention</code>等[155]在生成过程中逐步剪枝令牌，它会丢弃未来生成不再需要的部分上下文。</li></ul></li><li>Attention-pruning：<ul><li>如图11(d)所示，这些方法并非剪枝特定标记的所有注意力值，而是基于输入动态剪枝注意力的选择性部分。</li><li>该领域内一种重要的方法是将输入标记动态分割成组（称为桶），并策略性地省略位于不同桶中的标记的注意力计算。这些方法的挑战和重点在于如何将相关标记聚类在一起，从而仅在它们之间进行注意力计算以提高效率。</li><li><code>Reformer</code>[156]利用局部敏感哈希将具有相同哈希码的键和查询聚类到同一个桶中。</li><li>在此基础上，<code>Sparse Flash Attention</code>[157]引入了专门针对这种基于哈希的稀疏注意力机制优化的GPU内核，进一步提高了计算效率。</li><li>同时，<code>Routing Transformer</code>[158]采用球形k均值聚类算法将标记聚合到桶中，优化了注意力计算的选择过程。</li><li><code>Sparse Sinkhorn Attention</code>[159]采用学习排序网络将键与相关的查询桶对齐，确保仅在相应的查询-键对之间计算注意力。</li><li>与桶级操作不同，<code>H2O</code>[160]引入了标记级动态注意力剪枝机制。它将静态局部注意力与当前查询和一组动态识别的关键标记（称为重击者（H2））之间的动态计算相结合。这些重击者通过逐出策略动态调整，旨在在每个生成步骤中移除最不重要的键，有效管理重击者集合的大小和相关性。</li></ul></li><li>此外，将每个标记视为图节点并将标记之间的注意力视为边，为静态稀疏注意力提供了扩展视角[150]，[161]。原始的全注意力机制相当于具有均匀最短路径距离1的完全图。稀疏注意力通过其随机掩码引入随机边，有效地将任意两个节点之间的最短路径距离减少到O(logn)，从而保持类似于全注意力的高效信息流。Diffuser[161]利用图论视角，通过多跳标记相关性扩展稀疏注意力的感受野。它还从扩展器图特性中汲取灵感，设计出更优的稀疏模式，以近似全注意力的信息流。</li><li><code>Spatten</code>[153]还将剪枝从令牌粒度扩展到注意力头粒度，消除非必要注意力头的计算，以进一步降低计算和内存需求</li></ul></li></ul></li></ul><h4 id="2323-结构优化"><a class="markdownIt-Anchor" href="#2323-结构优化"></a> 2.3.2.3 结构优化</h4><h5 id="23231-神经架构搜索-nas"><a class="markdownIt-Anchor" href="#23231-神经架构搜索-nas"></a> 2.3.2.3.1. 神经架构搜索 (NAS)</h5><p>旨在自动搜索最优的神经架构来平衡性能和效率</p><ul><li><code>AutoTinyBERT</code> [135]利用一次性神经架构搜索（NAS）来发现Transformer架构的超参数。值得注意的是，它引入了一种引人注目的批次训练方法来训练超级预训练语言模型（SuperPLM），随后采用进化算法来识别最优子模型。</li><li><code>NAS-BERT</code> [136] 使用多种创新技术，如块级搜索、搜索空间剪枝和性能近似，在传统的自监督预训练任务上训练大型超级网络。这种方法使NAS-BERT能够高效应用于各种下游任务，而无需大量重新训练。通过NAS进行结构剪枝 [137] 将结构剪枝视为多目标NAS问题，并通过一次性NAS方法解决。</li><li><code>LiteTransformerSearch</code> [138]提出使用无需训练的指标，即参数数量，作为代理指标来指导搜索。该方法能够高效探索和选择最优架构，且在搜索阶段无需实际训练。</li><li><code>AutoDistil</code> [139]提出了一种完全与任务无关的少样本NAS算法，其特点是三种主要技术：搜索空间划分、与任务无关的SuperLM训练和与任务无关的搜索。这种方法旨在通过最少的任务特定适应，促进跨各种任务的高效架构发现。通常，NAS算法需要评估每个采样架构的性能，这可能会产生显著的训练成本。因此，这些技术难以应用于大型语言模型。</li></ul><h5 id="23232-低秩分解-lrf"><a class="markdownIt-Anchor" href="#23232-低秩分解-lrf"></a> 2.3.2.3.2. 低秩分解 (LRF)</h5><p><img src="/2025/10/01/llm/Pasted image 20251003140400.png" alt="img" width="659px"></p><ul><li><code>LoRD</code>表明，通过低秩分解（LRF）压缩大型语言模型（LLMs）具有潜力，且不会大幅降低性能。具体而言，它采用奇异值分解（SVD）对权重矩阵进行因式分解，并成功将一个拥有160亿参数的大型语言模型压缩至123亿，性能下降极小。</li><li><code>TensorGPT</code>提出了一种使用张量列车分解来压缩嵌入层的方法。每个标记嵌入都被视为矩阵乘积态（MPS），并以分布式方式高效计算。</li><li><code>LoSparse</code>结合了低秩分解和权重剪枝在大型语言模型压缩方面的优势。通过利用低秩近似，LoSparse降低了直接模型剪枝中通常会出现的丢失过多表达性神经元的风险。</li><li>LPLR 和 ZeroQuant-V2均提出通过同时对权重矩阵应用低秩分解和量化来对其进行压缩。</li><li><code>DSFormer</code>提出将权重矩阵分解为半结构化稀疏矩阵和小型密集矩阵的乘积。</li><li><code>ASVD</code>设计了一种激活感知的 SVD方法。该方法包括在应用 SVD进行矩阵分解之前，基于激活分布对权重矩阵进行缩放。ASVD还包括通过搜索过程为每个层确定合适的截断秩</li></ul><h4 id="2324-知识蒸馏"><a class="markdownIt-Anchor" href="#2324-知识蒸馏"></a> 2.3.2.4. 知识蒸馏</h4><p><img src="/2025/10/01/llm/Pasted image 20251003140905.png" alt="img" width="670px"></p><h5 id="23241-白盒知识蒸馏"><a class="markdownIt-Anchor" href="#23241-白盒知识蒸馏"></a> 2.3.2.4.1. 白盒知识蒸馏</h5><p>利用教师模型结构和参数访问权限的蒸馏方法。该方法使知识蒸馏能够有效利用教师模型的中间特征和输出logits，从而提升学生模型的性能。</p><ul><li><code>MiniLLM</code> [129]提出采用标准的白盒知识蒸馏方法，但将正向KL散度（KLD）替换为反向KL散度。</li><li><code>GKD</code>[130]引入了策略内数据的使用，其中包括学生模型自身生成的输出序列，以进一步蒸馏学生模型。该方法侧重于使用这些策略内数据对齐教师和学生模型之间的输出logits。</li><li><code>TED</code> [131]提出了一种任务感知的分层知识蒸馏方法。该方法包括在教师和学生模型的每一层之后添加过滤器，训练这些特定于任务的过滤器，随后冻结教师模型的过滤器，同时训练学生过滤器以使其输出特征与相应的教师过滤器对齐。</li><li><code>MiniMoE</code> [133] 通过将混合专家（Mixture-of-Experts，MoE）模型用作学生模型来缓解容量差距。</li><li>对于新出现的实体，预训练语言模型（LLMs）可能缺乏最新信息。为了解决这个问题，一种解决方案是在提示中加入额外的检索文本，尽管这会增加推理成本。或者，KPTD [134]建议通过知识蒸馏将实体定义中的知识转移到LLM参数中。该方法基于实体定义生成转移集，并蒸馏学生模型，使其基于这些定义与教师模型的输出分布相匹配。</li></ul><h5 id="23242-黑盒知识蒸馏"><a class="markdownIt-Anchor" href="#23242-黑盒知识蒸馏"></a> 2.3.2.4.2. 黑盒知识蒸馏</h5><p>黑箱知识蒸馏是指教师模型的结构和参数不可用的知识蒸馏方法.通常，黑盒知识蒸馏仅使用教师模型获得的最终结果。</p><ul><li>关于ICL能力，<ul><li><code>Multitask-ICT</code>[116]引入了上下文学习蒸馏，以迁移大型语言模型（LLMs）的多任务少样本能力，同时利用了上下文学习和语言建模的优势。</li><li><code>MCKD[</code>117]观察到，从经过上下文学习的教师模型中蒸馏出的学生模型在未见过的输入提示上通常表现出更优的性能。基于这一观察，MCKD设计了一种多阶段蒸馏范式，其中前一阶段的学生模型被用于为后续阶段生成蒸馏数据，从而提高蒸馏方法的有效性。</li></ul></li><li>为了提炼思维链（CoT）推理能力，一些技术如Distilling Step-by-Step [118]、SCoTD [119]、CoT Prompting [120]、MCC-KD [121]和Fine-tune-CoT [122]提出了蒸馏方法，这些方法结合了从大型语言模型中提取的响应和推理过程来训练学生模型。<ul><li><code>Socratic CoT</code> [123]也致力于将推理能力迁移到更小的模型中。具体而言，它对一对学生模型进行微调，即问题生成（QG）模型和问答（QA）模型。QG模型经过训练，能够基于输入问题生成中间问题，从而引导QA模型生成最终响应。</li><li><code>PaD</code> [124]观察到错误推理（即最终答案正确但推理步骤错误）可能对学生模型有害。为了解决这个问题，PaD提出为推理问题生成合成程序，然后可以通过额外的解释器对这些程序进行自动检查。这种方法有助于去除具有错误推理的蒸馏数据，提高学生模型训练数据的质量。</li></ul></li><li>针对指令跟随能力，已有多种方法被提出以将这种能力迁移到更小的模型中。<ul><li><code>DISCO</code> [126]引入了一种技术，即使用大型语言模型生成短语扰动。然后，由特定任务的教师模型对这些扰动进行筛选，以提炼高质量的反事实数据。</li><li><code>LaMini-LM</code> [127]旨在通过设计多样化的指令集来迁移指令跟随能力，从而对学生模型进行蒸馏。Lion [128]利用教师模型识别困难指令，并生成新的复杂指令来对小型模型进行蒸馏。</li></ul></li></ul><h4 id="2325-动态推理"><a class="markdownIt-Anchor" href="#2325-动态推理"></a> 2.3.2.5. 动态推理</h4><p>本节重点介绍早期退出技术，该技术使大型语言模型能够根据特定样本或标记在不同的模型层停止推理。值得注意的是，虽然混合专家技术（在5.1.1节讨论）在推理过程中也会调整模型结构，但它们通常需要高昂的预训练成本。相比之下，早期退出技术只需训练一个小型模块来决定何时结束推理。我们将早期退出技术的研究分为两种主要类型：样本级早期退出和标记级早期退出（如图13所示）。<br><img src="/2025/10/01/llm/Pasted image 20251003142229.png" alt="img" width="456px"></p><h5 id="23251-采样级"><a class="markdownIt-Anchor" href="#23251-采样级"></a> 2.3.2.5.1. 采样级</h5><p>对于每一个输入采样,决定最优尺寸和大语言模型结构</p><ul><li>一种常见的方法是在每一层之后为大型语言模型增加额外的模块，利用这些模块来决定是否在特定层终止推理。<ul><li><code>FastBERT</code>、<code>DeeBERT</code>、<code>MP</code>和<code>MPEE</code>直接训练这些模块，使其基于当前层的特征做出决策（例如，输出0继续或1停止）。</li><li><code>Global Past-Future Early Exit</code>提出了一种方法，通过来自前序层和后续层的语言信息丰富这些模块的输入。由于推理过程中无法直接获取后续层特征，因此训练了一个简单的前馈层来估计这些未来特征。</li><li><code>PABEE</code> 将模块训练为直接预测的输出头，当预测结果保持一致时建议终止推理。</li><li><code>HASHEE</code>采用了一种非参数决策方法，其基于的假设是相似样本应在同一层退出推理。</li></ul></li></ul><h5 id="23252-token级"><a class="markdownIt-Anchor" href="#23252-token级"></a> 2.3.2.5.2. Token级</h5><p>在大语言模型推理的解码阶段， tokens是按顺序生成的，token级早退技术旨在为每个输出 token优化大语言模型的大小和结构。</p><ul><li><code>CALM</code> [108] 在每个 Transformer层后引入早退分类器，训练它们输出置信度分数，以决定是否在特定层停止推理。值得注意的是，在自注意力块中，计算每一层当前 token 的特征依赖于同一层中所有先前 token 的特征（即 KV缓存）。为解决因先前 token早退而导致的 KV缓存缺失问题，CALM提出将特征从退出层直接复制到后续层，实验结果表明性能仅略有下降。</li><li><code>SkipDecode</code> [109]解决了先前早退方法的局限性，这些局限性阻碍了它们在批量推理和 KV缓存中的适用性，从而限制了实际的加速增益。对于批量推理，SkipDecode为批次内的所有 token提出了统一的退出点。关于 KV缓存，SkipDecode确保退出点单调递减，以防止 KV缓存的重新计算，从而提高推理效率</li></ul><h4 id="233-建议和未来展望"><a class="markdownIt-Anchor" href="#233-建议和未来展望"></a> 2.3.3. 建议和未来展望</h4><ul><li>在高效结构设计领域，寻找Transformer的替代架构是一个新兴的研究方向。诸如Mamba [73]、RWKV [60]及其各自变体[101]、[104]等模型已在各类任务中展现出具有竞争力的性能，近年来备受关注。尽管如此，研究这些非Transformer模型是否可能比Transformer模型存在某些缺点仍然具有现实意义。同时，探索非Transformer架构与注意力操作的融合[74]、[103]、[216]是未来研究的另一个有前景的方向。</li><li>在模型压缩领域，量化是大语言模型（LLM）部署中主要采用的方法，这主要归因于两个关键因素。首先，量化为压缩LLM提供了一种便捷的方式。例如，采用训练后量化（PTQ）方法可在几分钟内将拥有70亿参数的LLM压缩为更小的形式。其次，量化有望大幅降低内存消耗并提高推理速度，同时仅带来微小的性能损失。这种权衡对于许多实际应用而言通常是可接受的。然而，值得注意的是，量化仍可能损害LLM的某些涌现能力，如自校准或多步推理能力。此外，在处理长上下文等特定场景中，量化可能导致显著的性能下降[204]。因此，需要谨慎选择合适的量化方法，以减轻这些特定情况下的性能下降风险</li><li>大量文献致力于研究稀疏注意力技术，以实现高效的长上下文处理。例如，最近的代表性工作StreamingLLM [148]仅通过恢复几个注意力汇聚标记就能处理400万个标记。尽管如此，这些方法往往会牺牲关键信息，导致性能下降。因此，在高效管理长上下文的同时保留必要信息，仍是未来探索的重要领域。关于权重剪枝技术，LLM-KICK [217]指出，当前最先进的方法即使在相对较低的稀疏率下也会经历显著的性能下降。因此，开发有效的权重剪枝方法以维持LLM性能，仍是一个新兴且关键的研究方向</li><li>模型结构的优化通常涉及神经架构搜索（NAS）的使用，这通常需要大量的计算资源，对其在大型语言模型（LLMs）压缩中的实际应用构成了潜在障碍。因此，研究采用自动结构优化进行大型语言模型压缩的可行性值得进一步探索。此外，低秩分解（LRF）等技术在压缩率和任务性能之间实现最佳平衡仍然面临挑战。例如，ASVD [146]在不损害大型语言模型推理能力的情况下，仅能实现10%至20%的适度压缩率。</li><li>除了采用单独的模型压缩技术外，多项研究还探索了不同方法的组合以压缩大型语言模型，利用它们各自的优势来提高效率。例如，MPOE [88]专门对基于混合专家（MoE）的大型语言模型中的专家前馈网络（FFNs）应用权重矩阵分解，旨在进一步降低内存需求。LLM-MQ [191]利用权重稀疏性技术在模型量化过程中保护权重离群值，从而最大限度地减少量化误差。LPLR [143]专注于对低秩分解的权重矩阵进行量化，以进一步降低大型语言模型推理过程中的内存占用和内存访问成本。此外，LoSparse [142] 将低秩分解与权重剪枝相结合，利用剪枝来增强低秩近似的多样性，同时通过低秩分解保留重要权重并防止关键信息丢失。这些方法凸显了集成多种压缩技术以实现大型语言模型更好优化的潜力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> llm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llm_infra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构想的游戏-k小镇</title>
      <link href="/2025/04/01/game/"/>
      <url>/2025/04/01/game/</url>
      
        <content type="html"><![CDATA[<h1 id="缘起"><a class="markdownIt-Anchor" href="#缘起"></a> <strong>缘起</strong></h1><hr><p>为什么会想做一个游戏？大二上，我上了一门课叫<strong>人工智能导论</strong>，在做某次作业的时候我看到了这样一道题：<br><img src="/2025/04/01/game/image0.png" alt><br>一边在做作业我就一边在想：如果能实现一个小镇，上面所有的人都有<strong>自己的意识</strong>，每个都按照<strong>自己的性格</strong>以及这个小镇上的一些<strong>规则自由的生活</strong>，那该多有意思。这让我想起来小时候特别喜欢玩 <em>模拟城市：我是市长<s>破解版</s></em>，喜欢在上帝视角操纵一个城市的发展和里面小人物的活动，那时就觉得很有意思。</p><h1 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> <strong>设计</strong></h1><hr><p>下面来讲讲我现在是怎么想的吧！以防我过两天忘了hhhh。</p><ul><li>既然我们要设计一个自动化的小镇，首先得有一个管理<strong>小镇规则</strong>📑，这个规则就像是<strong>人类社会的伦理</strong>。简单来说:“<strong>没有规矩, 不成方圆</strong>”. 比如：每天早上6点某些店铺才会开门，之类的。我们需要规范所有计算结果的输出，使之符合我们的约定！<ul><li>这采用什么来实现呢？目前没想到什么其他的办法，也许纯手写逻辑？hh</li></ul></li><li>小镇有各种<strong>可传递的信息</strong>: 作为小镇人的感知输入<ul><li>比如: 天气, 时间, 大流行疾病 等等等</li></ul></li><li>小镇还得有<strong>居民</strong>👫。（不然建小镇来干嘛？这话说的就像“写字一定要用笔啊🖐️😭🖐️&quot;). 每个居民都有<strong>自己的性格, 有自己的想法, 对于外部的一个事件, 他会做出自己的反应</strong>. 比如: 下雨了, 输入到不同人物的大脑里, 产生的输出不一样, 有的人会直接冲回家里, 有的人可能会慢悠悠掏出伞, 在雨中漫步 (在生活中, 我应该是后者).<ul><li>每个居民都要<strong>有脑子</strong>🧠(没脑子还玩什么, 设置一个随机数说不定ta下雨的时候就会跳舞, 诶等等, <s>好像也还挺好玩</s>)<ul><li>脑子用什么实现? 可以每个人训练一个决策树?或者每个人一个神经网络?</li><li>输入: 应该是环境: 比如天气…等信息</li><li>输出: 应该是一个<strong>行为</strong></li><li>我还希望他会因为自己的行为而学到什么, 或者性格做出改变. 这怎么做? maybe 强化学习</li></ul></li><li><strong>心情值系统</strong>🤣😭 : 我希望他和一个真正的人一样, 因为人总是通过情绪来学习一些习惯(比如:你上课迟到, 然后被老师骂了,你感觉很沮丧, 暗自决定下次一定<s>不能</s>再这样). 而对于不同性格的人, 他们的心情值系统应该完全不同!<ul><li>就比如上面说的那个情况: 有些人很敏感, <strong>被老师骂对他的世界观冲击太大了</strong>, 他做出的决定很极端 ,他决定下次<em>绝对不会</em>再犯. 而有些人大大咧咧, 他觉得无所谓, 骂就骂呗, 这对他的心情值<strong>影响不大</strong>, 于是他做出的改变应该很温和.</li><li>这几乎对应了强化学习的setting. 但是如何设定不同的事件对不同性格的人影响有些困难, 甚至对于成百上千的居民都要这么做, 我不想累死.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 沉思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lean4学习笔记</title>
      <link href="/2025/03/15/lean4-learning/"/>
      <url>/2025/03/15/lean4-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定理和编程"><a class="markdownIt-Anchor" href="#1-定理和编程"></a> 1. 定理和编程</h1><h2 id="11-类型定义"><a class="markdownIt-Anchor" href="#11-类型定义"></a> 1.1. 类型定义</h2><h3 id="111-自然数的定义"><a class="markdownIt-Anchor" href="#111-自然数的定义"></a> 1.1.1 自然数的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inductive Nat: Type where</span><br><span class="line">| zero:Nat</span><br><span class="line">| succ:Nat \to Nat</span><br></pre></td></tr></table></figure><ol><li>第一行代表着我们要定义一个新的类型叫做<code>Nat</code>代表自然数</li><li>第二行和第三行声明了两个构造子,<code>Nat.zero</code>和<code>Nat.succ</code>可以用来构造<code>Nat</code>的值<ol><li>递归的基项是<code>zero</code></li><li>第二项是递归的<br>![[Pasted image 20250315114535.png|300]]<br>一个更加普遍的递归类型定义的声明方式是:<br>![[Pasted image 20250315114803.png|700]]</li></ol></li></ol><p>通常在lean文件里, 我们把类的定义包含在名空间里<code>namespace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace MyNat</span><br><span class="line">...</span><br><span class="line">end MyNat</span><br></pre></td></tr></table></figure><p>在<code>end MyNat</code>外面再使用<code>Nat</code>就是Lean库里预定义的<code>Nat</code>而不是我们刚刚定义的那个. 我们可以通过名空间包含整个文件的方式来防止我们定义的变量和预定义的相冲突</p><p>我们可以用<code>#print Nat</code>来展示我们之前的定义的类的一些信息</p><h3 id="112-算术表达式的定义"><a class="markdownIt-Anchor" href="#112-算术表达式的定义"></a> 1.1.2 算术表达式的定义</h3><p>下面给出了一个算术表达式的递归定义<br>![[Pasted image 20250315120555.png|600]]<br>事实上这个定义在数学上等价于</p><ol><li>对于一个整数<code>i</code> ,<code>AExp.num i</code>是一个<code>AExp</code>的值</li><li>一个字符串<code>x</code> ,<code>AExp.var x</code>是一个<code>AExp</code>的值</li><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是<code>AExp</code>的值那么<code>AExp.add e1 e2</code>也是 <code>AExp.sub e1 e2</code>也是…<br>上述定义是详尽的。AExp唯一可能的值是使用1到3的构造规则构建的值。<br>就像我们在上面讲到的自然数的例子, 自然数是0以及由0递归加1得到的数的总和</li></ol><h3 id="113-列表的定义"><a class="markdownIt-Anchor" href="#113-列表的定义"></a> 1.1.3. 列表的定义</h3><p>![[Pasted image 20250315121806.png|600]]<br>该类型是多态的：它由类型α参数化，我们可以用具体类型实例化它。例如，List Z是整数列表的类型，List （List R）是实数列表的列表类型。</p><h2 id="12-方程定义"><a class="markdownIt-Anchor" href="#12-方程定义"></a> 1.2. 方程定义</h2><p>![[Pasted image 20250315132447.png|600]]</p><h3 id="121-自然数上的递归"><a class="markdownIt-Anchor" href="#121-自然数上的递归"></a> 1.2.1 自然数上的递归</h3><p>![[Pasted image 20250315132841.png|500]]<br>我们可以看到fib这个函数需要一个N作为输入, 这个输入会自动匹配到下面的case里, 比如说如果我们输入1, 那么模板 1 就会匹配, 如果我们输入的是5, 那么就会匹配模板 n+2.</p><p>![[Pasted image 20250315133052.png|600]]<br>如果有多个参数的情况下, 参数params1到paramsm不能进行模式匹配，只有在type中声明的其余参数才能进行模式匹配。<br>在这个例子里, 我们分为两个情况:</p><ol><li>第二个参数是0</li><li>第二个参数不是0的情况, 每次调用一个<code>add</code>就会剥离一个<code>Nat.succ</code><br>![[Pasted image 20250315140955.png]]</li></ol><h3 id="122-递归算术表达式"><a class="markdownIt-Anchor" href="#122-递归算术表达式"></a> 1.2.2 递归算术表达式</h3><p>![[Pasted image 20250315141833.png|600]]<br>这个函数是什么意思呢? 我们看看下面这个例子吧<br>![[Pasted image 20250315141851.png|800]]<br>输入一个函数(fun x =&gt; 7)把所有的字符串都映射到数字7, 记者输入一个算术表达式(也就是要计算的目标)</p><ol><li>读入<code>AExp.div</code>递归两个eval, 第一个eval输入函数env 和表达式(<code>AeExp.var &quot;y&quot;</code>), 第二个表达式也是类似的,</li><li>接着进一步调用eval这个函数, 那么这时候就匹配到第二个情况也就是<code>AeExp.var &quot;y&quot;</code>这时候就要执行<code>env &quot;y&quot;</code>按照条件那就是得到数字7, 按照相同的方法也可以计算<code>eval env (Aexp.num 0)</code></li></ol><h2 id="13-定义陈述"><a class="markdownIt-Anchor" href="#13-定义陈述"></a> 1.3. 定义陈述</h2><p>![[Pasted image 20250315143039.png|700]]<br><code>:=</code>后面跟着的是这个定理的证明</p><p>![[Pasted image 20250315143246.png|200]]<br>![[Pasted image 20250315143304.png|500]]<br>这里的<code>axiom</code>是公理, 是毋庸置疑的, 是不需要证明的.</p><h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2><p>![[Pasted image 20250315143539.png|700]]</p><h1 id="2-后向证明"><a class="markdownIt-Anchor" href="#2-后向证明"></a> 2. 后向证明</h1><p>考虑定理a,a→b和b→c以及目标 c, 那么要证明c,</p><ul><li>什么是后向证明? 由于b-&gt;c那么证明b就够了,要证明b,那么证明a就够了, 要证明a ,我们使用前提a. 后向证明每一步都有一个目标(goal)</li><li>那一定有前向证明吧? 有的兄弟,有的. 同样的问题我们要这样考虑: 从已经有的条件a, 我们可以推出b成立, 由于b成立, 那么我们可以推出c成立,得证.前向证明只处理定理, 而没有一个目标</li></ul><h3 id="21-tactic-mode策略模式"><a class="markdownIt-Anchor" href="#21-tactic-mode策略模式"></a> 2.1. Tactic Mode(策略模式)</h3><p>策略在目标上操作，目标由我们想要证明的命题Q和局部上下文c组成。局部上下文由形式为<code>x: σ</code>的变量声明和形式为<code>h: P</code>的假设组成. 为了说的更清楚一点我们考虑这样一个例子:<br>![[Pasted image 20250315144650.png|500]]</p><ol><li>最开始的情况,我们还没有进行证明<br>![[Pasted image 20250315144859.png|400]]<br>可以看到我们有一个目标</li><li>接下来我们<code>intro a b</code>这实际上是固定了定理所说的任意a,b<br>![[Pasted image 20250315145350.png|300]]<br>这时候我们就有了一个局部上下文, 我们要证明的目标也发生了改变</li><li><code>intro ha hb</code>实际上是引入了定理a成立的证明ha和定理b成立的证明.<br>![[Pasted image 20250315145913.png|200]]<br>这时候所有的输入都已经被引入完成了, 最后要证明a, 那我们只要使用上面引入的定理a的证明就行了</li></ol><p>对于上面的例子我们也可以避免使用intro, 只要我们稍微改变一下写法<br>![[Pasted image 20250315150154.png|800]]<br>同样的我们还可以考虑下面这个情况:<br>![[Pasted image 20250315150311.png]]</p><h2 id="22-基础的策略"><a class="markdownIt-Anchor" href="#22-基础的策略"></a> 2.2. 基础的策略</h2><h3 id="intro"><a class="markdownIt-Anchor" href="#intro"></a> intro</h3><ul><li>语法<br><code>intro [name1 . . . namen ]</code></li><li>intro可以将输入的变量转换为上下文, 什么? 你问我什么是输入的变量. 实际上可以这么理解: 就是你所要证明的那个命题的前提, 或者更加简单粗暴一点, 就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span>后面的或者是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>左边的东西(前件)</li></ul><h3 id="rfl"><a class="markdownIt-Anchor" href="#rfl"></a> rfl</h3><ul><li>当你要证明的东西是<code>r=l</code>, 并且这两个东西在语义上是相等的.<br>![[Pasted image 20250315151145.png|500]]<br>Often, <code>rfl</code> succeeds where a mathematician would say<code>“by definition.”</code></li></ul><h3 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> apply</h3><ul><li>语法<br><code>apply theorem-or-hypothesis</code></li><li>应用策略将目标的目标与特定定理或假设的结论相匹配，并将该定理或假设的假设作为新目标添加。</li></ul><h3 id="exact"><a class="markdownIt-Anchor" href="#exact"></a> exact</h3><ul><li>语法<br><code>exact theorem-or-hypothesis</code></li><li>精确的策略将目标的目标与特定的定理或假设相匹配，从而证明目标。在这种情况下，我们通常可以使用<code>apply</code>，但<code>exact</code>更能传达我们的意图。</li></ul><h3 id="assumption"><a class="markdownIt-Anchor" href="#assumption"></a> assumption</h3><p>假设策略是从局部情境中寻找一个与目标相匹配的假设，并应用它来证明目标。</p><h2 id="23-逻辑连接词和量词"><a class="markdownIt-Anchor" href="#23-逻辑连接词和量词"></a> 2.3. 逻辑连接词和量词</h2><h3 id="231-合取引入"><a class="markdownIt-Anchor" href="#231-合取引入"></a> 2.3.1. 合取引入</h3><p><code>And.intro : a → b → a ∧ b</code></p><h3 id="232-合取消除"><a class="markdownIt-Anchor" href="#232-合取消除"></a> 2.3.2 合取消除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">And.left : a ∧ b → a </span><br><span class="line">And.right : a ∧ b → b</span><br></pre></td></tr></table></figure><p>![[Pasted image 20250315154506.png|500]]<br>每个 <code>&#123;&#125;</code>代表着引入的命题</p><h3 id="233-析取引入"><a class="markdownIt-Anchor" href="#233-析取引入"></a> 2.3.3. 析取引入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Or.inl : ∀b : Prop, a → a ∨ b</span><br><span class="line">Or.inr : ∀b : Prop, a → b ∨ a</span><br></pre></td></tr></table></figure><h3 id="234-析取消去"><a class="markdownIt-Anchor" href="#234-析取消去"></a> 2.3.4. 析取消去</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Or.elim : a ∨ b → (a → c) → (b → c) → c</span><br></pre></td></tr></table></figure><h3 id="235-等价引入-消去"><a class="markdownIt-Anchor" href="#235-等价引入-消去"></a> 2.3.5. 等价引入, 消去</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iff.intro : (?a → ?b) → (?b → ?a) → (?a ↔ ?b) </span><br><span class="line">Iff.mp : (?a ↔ ?b) → ?a → ?b </span><br><span class="line">Iff.mpr : (?a ↔ ?b) → ?b → ?a</span><br></pre></td></tr></table></figure><h3 id="236-存在引入和消去"><a class="markdownIt-Anchor" href="#236-存在引入和消去"></a> 2.3.6 存在引入和消去</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exists.intro : ∀w, (?P w → (∃x, ?P x)) </span><br><span class="line">Exists.elim : (∃x, ?P x) → (∀a, ?P a → ?c) → ?c</span><br></pre></td></tr></table></figure><p>![[Pasted image 20250315162536.png|400]]</p><h3 id="237-经典逻辑"><a class="markdownIt-Anchor" href="#237-经典逻辑"></a> 2.3.7. 经典逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Classical.em : ∀a : Prop, a ∨ ¬ a </span><br><span class="line">Classical.byContradiction : (¬ a → False) → a</span><br></pre></td></tr></table></figure><h3 id="summary-2"><a class="markdownIt-Anchor" href="#summary-2"></a> summary</h3><ol><li>遇到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span>我们可以尝试使用<code>intro</code>策略</li><li>遇到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P\to Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>且目标是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>的时候我们可以<code>apply</code>它</li><li>如果遇到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">\neg P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>   可以<code>intro hp</code>证明<code>False</code></li></ol><h2 id="24-递归策略"><a class="markdownIt-Anchor" href="#24-递归策略"></a> 2.4. 递归策略</h2><p>![[Pasted image 20250315163713.png|500]]</p><h2 id="25-rewiting-策略"><a class="markdownIt-Anchor" href="#25-rewiting-策略"></a> 2.5. rewiting 策略</h2><h3 id="at"><a class="markdownIt-Anchor" href="#at"></a> at</h3><p><code>at h1 . . . hn</code> rewrites the specified hypotheses<br><code>at *</code> rewrites all hypotheses and the target</p><h3 id="rw"><a class="markdownIt-Anchor" href="#rw"></a> rw</h3><p><code>rw [theorem-or-constant1, . . . , theorem-or-constantn] [at position]</code></p><h2 id="26-cleanup策略"><a class="markdownIt-Anchor" href="#26-cleanup策略"></a> 2.6. cleanup策略</h2><h3 id="clear"><a class="markdownIt-Anchor" href="#clear"></a> clear</h3><p><code>clear variable-or-hypothesis1 . . . variable-or-hypothesisn</code></p><p>移除没用的变量和假设</p><h3 id="rename"><a class="markdownIt-Anchor" href="#rename"></a> rename</h3><p><code>rename type-of-variable-or-proposition-of-hypothesis =&gt; new-name</code></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理逻辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复ubuntu网络断开</title>
      <link href="/2025/03/12/howtofixubuntu/"/>
      <url>/2025/03/12/howtofixubuntu/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h1><p>在ubuntu的终端输入命令<code>ifconfig</code>弹出<code>127.0.0.1</code>而没有虚拟机的ip地址, 如下图所示<br><img src="/2025/03/12/howtofixubuntu/image.png" alt="alt text"></p><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><ol><li>在终端输入<code>sudo dhclient -v</code>此时再输入<code>ifconfig</code>虚拟机ip地址就出现了<br><img src="/2025/03/12/howtofixubuntu/image2.png" alt="alt text"></li><li>主机<code>ping</code>一下虚拟机ip就能<code>ping</code>到了</li><li>如果还是不行,</li><li><ol><li>可以在主机的命令行里输入<code>ipconfig -all</code>查看虚拟机的ip地址和在虚拟机里的ip地址是不是一样的</li></ol></li><li><ol start="2"><li>如果不一样, <code>win+R</code> 然后输入 <code>ncpa.cpl</code> 进入面板</li></ol></li><li><ol start="3"><li>右键 <code>VMnet8</code> 点击属性,双击<code>Internet协议版本4(TCP/IPV4)</code></li></ol></li><li><ol start="4"><li>选择手动, ip地址啥的就从虚拟机的<code>ifconfig</code>里的ip填进去</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2025/01/22/hello-world/"/>
      <url>/2025/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="try-try"><a class="markdownIt-Anchor" href="#try-try"></a> try try</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    mindmap  root((mindmap))    Origins      Long history      ::icon(fa fa-book)      Popularisation        British popular psychology author Tony Buzan    Research      On effectiveness&lt;br&#x2F;&gt;and features      On Automatic creation        Uses            Creative techniques            Strategic planning            Argument mapping    Tools      Pen and paper      Mermaid  </pre></div><h1 id="hexo怎么发布文章"><a class="markdownIt-Anchor" href="#hexo怎么发布文章"></a> hexo怎么发布文章?</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g //生成静态文件</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s //本地预览</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d //发布到服务器</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
